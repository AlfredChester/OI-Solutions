摘要：Slope trick, 可并堆

[传送门：https://www.luogu.com.cn/problem/P3642](https://www.luogu.com.cn/problem/P3642)

## 题意

给定一颗树，边有边权。你可以调整边权到任意非负整数，调整后要使得每个叶子结点到根的距离都相等。调整一条边的代价是调整前后边权差的绝对值，整个调整方案的代价是所有边的调整代价之和。求最小代价。

## 分析思路

考虑记 $f_u(x)$ 表示从 $u$ 到所有叶子结点的距离都为 $x$ 的最小代价。则有：

$$
f_u(x) = \sum_{v \in \mathrm{child}(u)} \min_{y \le x} \{f_v(y) + |w - (x - y)|\}
$$

考虑记 $F_v(x) = \min_{y \le x} \{f_v(y) + |y + w - x|\}$，也就是 $v$ 对 $u$ 的贡献。绝对值把对 $y$ 的决策分成了两个区间：$[0, x - w]$ 以及 $(x - w, x]$。去掉绝对值，设到：

$$
F_v(x) = \min_{y \le x} \begin{cases}
f_v(y) - y + x - w, & 0 \le y \le x - w \\
f_v(y) + y - x + w, & x - w < y \le x 
\end{cases}
$$

**考虑 $f_v$ 中斜率为 $0$ 的区间 $[L, R]$ 从右到左扫描的过程（因为影响最优决策）**：

### 1. $x < L$

- $0 \le y \le x - w$：注意到 $f_v(y)−y$ 单调递减，其它不变， $f_v(x - w)$ 最优。

- $x - w < y \le x$：$y$ 每增大 $1$，由于斜率 $k \le -1$，所以 $f_v(y)$ 减小值 $\ge 1$，所以 $f_v(y) + y$ 单调递减，其它不变，取 $f_v(x) + w \le f_v(x−w)$ 最优。

综上这部分的最优值为 $f_v(x) + w$。

### 2. $x - w < L \le x \implies L \le x < L + w$

- $0 \le y \le x - w$：注意到 $f_v(y)−y$ 单调递减，其它不变， $f_v(x - w)$ 最优。

- $x - w < y \le L \le x$：同上可以知道决策点取 $L$，$f_v(L) + L - x + w \le f_v(x - w)$ 最优。$y > L$ 显然不优。

### 3. $L \le x - w < R \implies L + w \le x < R + w$

可以取 $[L, R]$ 中的任意 $y$，由于 $x - w$ 在这个区间内，能让绝对值取到最小值，$f_v(x - w) = f_v(L)$ 最优。

### 4. $R \le x - w \implies R + w \le x$

同理最优决策点为 $R$，值为 $f_v(R) - R + x - w = f_v(L) - R + x - w$。

整理一下 $F_v$：

$$
F_v(x) = \begin{cases}
f_v(x) + w, & x < L \\
f_v(L) + L - x + w, & L \le x < L + w \\
f_v(L), & L + w \le x < R + w \\
f_v(L) - R + x - w, & R + w \le x\\
\end{cases}
$$

然后你发现其实是把 $[L, R]$ 这一段往右平移了 $w$，$x < L$ 的部分斜率都不变，然后在 $R + w$ 之后的地方插入一条斜率为 $1$ 的射线。

然后其实就是你把 $[L, R]$ 找到就行了（后面斜率为正的拐点个数恰好就是孩子个数，弹出 $ch - 1$ 个之后最后一个就是 $R$）。更新完之后用可并堆合并到父亲上。

最后考虑算答案。$f_1(0)$ 显然就是边权之和。我们要求的是 $f_1(L)$，推一手式子：

$$
f_1(L) = f_1(0) + \sum_{i = 0}^{ch - 1} i(w_{i + 1} - w_i) = f_1(0) - \sum_{i = 0}^{ch} w_i
$$

然后就做完了。时间复杂度是 $O(n \log n)$。

## 代码

```cpp
#include <bits/extc++.h>
#include <bits/stdc++.h>
using namespace std;
const int N = 300010;
using i64 = long long;
int n, m, p[N], c[N], ch[N];
__gnu_pbds::priority_queue<i64> S[N];
inline void optimizeIO(void) {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
}
int main(int argc, char const *argv[]) {
    i64 ans = 0;
    optimizeIO(), cin >> n >> m;
    for (int i = 2; i <= n + m; i++) {
        cin >> p[i] >> c[i];
        ch[p[i]]++, ans += c[i];
    }
    for (int i = n + m; i >= 2; i--) {
        i64 L = 0, R = 0;
        if (i <= n) {
            while (--ch[i]) S[i].pop();
            R = S[i].top(), S[i].pop();
            L = S[i].top(), S[i].pop();
        }
        S[i].push(L + c[i]);
        S[i].push(R + c[i]);
        S[p[i]].join(S[i]);
    }
    while (ch[1]--) S[1].pop();
    while (!S[1].empty()) {
        ans -= S[1].top(), S[1].pop();
    }
    cout << ans << endl;
    return 0;
}

```
