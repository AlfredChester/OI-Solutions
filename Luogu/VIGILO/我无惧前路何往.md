摘要：线段树，矩阵乘法，数学

[传送门：https://www.luogu.com.cn/problem/T467515](https://www.luogu.com.cn/problem/T467515)

## 题意

给定 $n$ 个函数 $f_i(x) = a_ix + b_i$，需要维护两个操作：

- `1 x A B`：$a_x \gets A, b_x \gets B$；
- `2 l r x0`：求 $f_r(f_{r - 1}(\dots f_l(x_0))) \bmod {998244353}$。

## 分析思路

由于本题解为官方题解，所以也会分析部分分的解法，部分分解法的代码不附。

### Subtask I. 测试点编号 $1 \sim 4$

$O\left(nm\right)$ 暴力即可，不多赘述。

### Subtask II. 测试点编号 $5 \sim 6$

注意到每个 $f_i$ 都退化为常值函数。对于每个询问，答案即为 $b_r$。时间复杂度 $O\left(n + m\right)$。

### Subtask III. 测试点编号 $7 \sim 8$

这档部分分不是很好拿。

你可能会认为每个 $f_i$ 都是正比例函数，我们只要支持快速求出一段区间的积就可以了。一个比较 naive 的想法是记录区间前缀积，从而支持快速求出一段区间的积。

但是别忘了，$a_i$ 还可以是 $0$。例如我们考虑 $a = \{1, 0, 2, 3\}$。如果记 $P = \{1, 0, 0, 0\}$ 为 $a$ 的前缀积，在查询区间 $[3, 4]$ 的积时就会出现糟糕的错误（除数为 $0$）。

意识到这一点后，我们可以改良一下我们的方案。记 $P = \{1, 1, 2, 6\}$ 为 $a$ 中**非零元素**的前缀积（为 $0$ 直接继承前一个位置），$S = \{0, 1, 1, 1\}$ 为 $a$ 前缀含有 $0$ 的个数。

我们可以 $O\left(n\right)$ 预处理出上述 $P$ 与 $S$ 数组。那么对于每一次询问，我们先可以很容易地通过 $P$ 查询出一段区间是否有 $0$，若无 $0$ 再进一步计算出区间的积。注意这是带模除法，可以乘以其逆元。

时间复杂度 $O\left(n + m \log p\right)$，其中 $p = 998244353$。

### Subtask IV. 测试点编号 $9$

在 `Subtask II` 的基础上支持更改 $b_i$ 即可。时间复杂度 $O\left(n + m\right)$。

### Subtask V. 测试点编号 $10 \sim 13$

在 `Subtask III` 的基础上，我们失去了特殊性质 C。于是我们就要动态维护上述 $P$ 与 $S$ 数组。考虑使用树状数组（或其他数据结构）即可。

使用树状数组的时间复杂度为 $O\left(n + m \log n \log p\right)$，其中 $p = 998244353$。使用线段树的时间复杂度为 $O\left(n + m \log n\right)$，均可通过本档部分分。

### Subtask VI. 测试点编号 $14 \sim 15$

这档部分分及其不好拿，是给完全不会数据结构，但是数学注意力极佳的人准备的。正解和这档部分分关系极大。

### Subtask VII. 测试点编号 $16 \sim 20$

将 `Subtask VI` 中预处理的部分改为线段树即可，单点修改只需要定位到叶子结点重新赋值矩阵。时间复杂度 $O\left(n + m \log n\right)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 200010;
template <int mod>
inline int64_t down(int64_t x) { return x >= mod ? x - mod : x; }
template <int mod>
struct ModInt {
    int64_t x;
    ModInt() = default;
    ModInt(int64_t x) : x((x % mod + mod) % mod) {}
    friend istream &operator>>(istream &in, ModInt &a) { return in >> a.x; }
    friend ostream &operator<<(ostream &out, ModInt a) { return out << a.x; }
    friend ModInt operator+(ModInt a, ModInt b) { return down<mod>(a.x + b.x); }
    friend ModInt operator-(ModInt a, ModInt b) { return down<mod>(a.x - b.x + mod); }
    friend ModInt operator*(ModInt a, ModInt b) { return (__int128)a.x * b.x % mod; }
    friend ModInt operator/(ModInt a, ModInt b) { return a * ~b; }
    friend ModInt operator^(ModInt a, long long b) {
        ModInt ans = 1;
        for (; b; b >>= 1, a *= a)
            if (b & 1) ans *= a;
        return ans;
    }
    friend ModInt operator~(ModInt a) { return a ^ (mod - 2); }
    friend ModInt operator-(ModInt a) { return down<mod>(mod - a.x); }
    friend ModInt &operator+=(ModInt &a, ModInt b) { return a = a + b; }
    friend ModInt &operator-=(ModInt &a, ModInt b) { return a = a - b; }
    friend ModInt &operator*=(ModInt &a, ModInt b) { return a = a * b; }
    friend ModInt &operator/=(ModInt &a, ModInt b) { return a = a / b; }
    friend ModInt &operator^=(ModInt &a, long long b) { return a = a ^ b; }
    friend ModInt &operator++(ModInt &a) { return a += 1; }
    friend ModInt operator++(ModInt &a, int) {
        ModInt x = a;
        a += 1;
        return x;
    }
    friend ModInt &operator--(ModInt &a) { return a -= 1; }
    friend ModInt operator--(ModInt &a, int) {
        ModInt x = a;
        a -= 1;
        return x;
    }
    friend bool operator==(ModInt a, ModInt b) { return a.x == b.x; }
    friend bool operator!=(ModInt a, ModInt b) { return !(a == b); }
};
using mint = ModInt<998244353>;
struct Matrix {
    mint a[2][2];
    Matrix() {
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                a[i][j] = 0;
            }
        }
    }
    inline mint *operator[](int x) { return a[x]; }
    inline Matrix operator*(Matrix x) {
        Matrix ans;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 2; k++) {
                    ans[i][j] += a[i][k] * x[k][j];
                }
            }
        }
        return ans;
    }
};
struct Node {
    int l, r;
    Matrix sum;
    inline int mid(void) { return (l + r) >> 1; }
} tr[N << 2];
int n, m, opt, l, r, x, a[N], b[N];
inline void optimizeIO(void) {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
}
inline void assignLinear(Matrix &M, mint A, mint B) {
    M[0][0] = A, M[0][1] = B, M[1][0] = 0, M[1][1] = 1;
}
inline int ls(int p) { return p << 1; }
inline int rs(int p) { return p << 1 | 1; }
inline void build(int p, int l, int r) {
    tr[p] = {l, r};
    if (l == r) {
        return assignLinear(tr[p].sum, a[l], b[l]);
    }
    const int m = (l + r) >> 1;
    build(ls(p), l, m), build(rs(p), m + 1, r);
    tr[p].sum = tr[rs(p)].sum * tr[ls(p)].sum;
}
inline void modify(int p, int x, mint A, mint B) {
    if (tr[p].l == tr[p].r) {
        return assignLinear(tr[p].sum, A, B);
    }
    modify(x <= tr[p].mid() ? ls(p) : rs(p), x, A, B);
    tr[p].sum = tr[rs(p)].sum * tr[ls(p)].sum;
}
inline Matrix query(int p, int l, int r) {
    if (l <= tr[p].l && tr[p].r <= r) {
        return tr[p].sum;
    }
    const int m = tr[p].mid();
    if (l <= m && r <= m) {
        return query(ls(p), l, r);
    } else if (l > m && r > m) {
        return query(rs(p), l, r);
    } else {
        return query(rs(p), l, r) * query(ls(p), l, r);
    }
}
int main(int argc, char const *argv[]) {
    optimizeIO(), cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i] >> b[i];
    }
    build(1, 1, n);
    while (m--) {
        cin >> opt >> l >> r >> x;
        if (opt == 1) {
            modify(1, l, r, x); // pos is l, A = r, B = x
        } else {
            Matrix res = query(1, l, r);
            cout << res[0][0] * x + res[0][1] << '\n';
        }
    }
    return 0;
}
```
