摘要：二分，01-Trie

[传送门：https://www.luogu.com.cn/problem/CF1983F](https://www.luogu.com.cn/problem/CF1983F)

## 题意

给定一个长度为 $n$ 的数列 $a_n$。定义子段 $[l, r]$ 的价值为 $a[l, r] = \min(\{a_i \oplus a_j\})$，其中 $l \le i < j \le r$。

求出数列所有长度大于等于 $2$ 的子段中，价值第 $k$ 大的子段的价值。

## 分析思路

$k$ 大值很容易让我们想到二分答案。我们二分查找价值第 $k$ 大的子段的价值 $x$。`check` 需要我们统计所有子段中，价值小于 $x$ 的个数。

容易发现对于一个确定的 $r$，随着 $l$ 的增大，$a[l, r]$ 单调不减。换言之，如果我们找到了一个最大的左端点 $l_{max}$，使得 $a[l_{max}, r] < x$，则一定有 $\forall l \in [1, l_{max}], a[l, r] < x$。

在这一良好性质的启发下，我们考虑枚举 $r$。问题转化为维护一个由 $a_1, a_2, \dots, a_{r - 1}$ 组成的集合 $S$，支持我们查询使得最大的 $l \in [1, r - 1]$ 使得 $a_l \oplus a_r < x$。容易想到使用 01-Trie 维护。具体来说，我们从高位向第位贪心，设当前正在枚举第 $d$ 位。

- 若 $x$ 的第 $d$ 位为 $0$：此时在 Trie 上我们只能选择与 $a_r$ 的第 $d$ 位相同的子树，否则我们会制造出一个 $1$ 使得答案越界。
- 若 $x$ 的第 $d$ 位为 $1$：

## 代码

```cpp
```
