# 数学知识总结


<h1 id="数学知识总结">数学知识总结</h1>

<h3 id="质数">质数</h3>

唯一分解定理：一个自然数$n$可以被唯一分解为$n=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}$，其中$p_1,p_2\cdots p_k$为互不相同的质数。

<h4 id="质数筛法">质数筛法：</h4>

1.埃式筛：每筛一个数时，暴力地将这个数的所有倍数标记，最终没有被标记的就是质数

2.线性筛：每筛一个数的时候，枚举这个数的筛好的质数倍数，如果这个数是枚举的质数的倍数就停止，这样每个数只会被标记一遍，复杂度是线性的。

<h4 id="质数判定">质数判定：</h4>

如果$n$不大，可以枚举$\leqslant\sqrt n$的所有质数，复杂度$O(\frac{\sqrt n}{\ln(n)})$。

Miller_rabin算法：

根据费马小定理，对于质数$p$和与它互质的数$a$，有$a^{p-1}\equiv1\pmod p$，但是也有合数满足这个条件（即费马伪素数），于是又引入了二次探测定理：对于质数$p$，若$x^2\equiv 1\pmod p$，则小于$p$的$x$只有1和$p-1$。这样如果我们得到了$a^{p-1}\equiv1\pmod p$，且$p-1$为偶数，那这就等价与$(a^{\frac{p-1}{2}})^2\equiv1\pmod p$，这时就需要判断$a^{\frac{p-1}{2}}\mod p$是不是等于$p-1$或1，如果不是，$p$就不是质数，否则就继续判断$\frac{p-1}{4}\cdots$直到变为奇数。也就是说，假设要检验的数是$n$，就先将$n-1$化成$x\times 2^y$的形式，然后对$a^x,a^{2x},a^{2^2x}$，这些数的解要么是全1，要么是出现$p-1$后全1，否则就不是质数。

<h4 id="分解质因数">分解质因数：</h4>

1.线性筛预处理出每个数的最小质因子，然后不断除最小质因子即可，复杂度$O(\log n)$。

2.Pollard Rho算法：

考虑到用试除法枚举因子的复杂度是$O(\sqrt n)$，我们尝试用随机化，即每次随机一个数计算与$n$的$gcd$，但这样最坏复杂度是$\sqrt n\log n$的，于是我们需要优化随机方法。首先，根据生日悖论，假设有$n$有一个因子$p$，那么期望枚举$\sqrt p$个随机数就可以得到两个数的差是$p$的倍数。不过验证两两的差复杂度还是很高，于是我们尝试用伪随机数，即设$f(x)=x^2+c$，随机数为$x,f(x),f(f(x))\cdots$，不过可以观察发现这个序列是混循环序列，于是需要判环。这里采用floyd判环法，即一个人每次变成$f(x)$，另一个人$f(f(x))$，这样一定会相遇。同时，由于$f(x)=x^2+c$，如果$|i-j|\equiv 0\pmod p$，那么有$|f(i)-f(j)|\equiv0\pmod p$，因此每次移动时相当于检查一个新的数。这样的复杂度时$O(n^{\frac{1}{4}}\log n)$的。不过我们可以考虑每固定$C$距离再算一次gcd，这样就可以做到期望$O(n^{\frac{1}{4}})$。

<h3 id="因数倍数">因数倍数</h3>

$\gcd(a,b)$表示$a,b$的最大公约数，$\text{lcm}(a,b)$表示$a,b$的最小公倍数，求法：辗转相除法，更相减损法。

<h3 id="同余">同余</h3>

数论倒数（逆元）：满足$a\times a^{-1}\equiv1\pmod p$的$a^{-1}$就叫做$a$在模$p$意义下的逆元。

<h4 id="费马小定理">费马小定理：</h4>

对于质数$p$，$a^{p-1}\equiv1\pmod p$。

<h4 id="欧拉定理">欧拉定理：</h4>

若$a\perp p$（即$\gcd(a,p)=1$），则$a^{\varphi(p)}\equiv1\pmod p$

<h4 id="拓展欧拉定理">拓展欧拉定理：</h4>

对于任意$a,b,p(b\geqslant\varphi(p))$，$a^b\equiv a^{b\mod\varphi(p)+\varphi(p)}\pmod p$

<h4 id="威尔逊定理">威尔逊定理：</h4>

对于质数$p$，$(p-1)!\equiv-1\pmod p$

<h4 id="阶和原根">阶和原根：</h4>

阶：对于$a\perp p$的$a,p$，满足$a^n\equiv1\pmod p$的最小正整数$n$叫做$a$模$p$的阶，记为$\delta_p(a)$。

性质：

1.$a,a^2,\cdots a^{\delta_p(a)}$两两不同余

2.若$a^i\equiv a^j\pmod p$，则$i\equiv j\pmod{\delta_p(a)}$

原根：对于$a\perp p$，若$\delta_p(a)=\varphi(p)$，则$a$叫做$p$的原根。

<h3 id="同余方程">同余方程</h3>

<h4 id="拓展欧几里得">拓展欧几里得：</h4>

用于求解形如$ax+by=gcd(a,b)$的二元一次不定方程组，思路如下：

若已知一组满足条件的解$x_0,y_0$，则这组解满足$bx_0+(a\bmod b)y_0=gcd(a,b)$,由此可得$ax+by=bx_0+(a\bmod b)y_0$

而取模运算$a\bmod b$等同于$a-b\times\left\lfloor\frac{a}{b}\right\rfloor$，因此又可以推出：

$ax+by=bx_0+(a-b\times\left\lfloor\frac{a}{b}\right\rfloor)y_0$

$\Rrightarrow ax+by=bx_0+ay_0-b\times\left\lfloor\frac{a}{b}\right\rfloor y_0=ay_0+b(x_0-\left\lfloor\frac{a}{b}\right\rfloor y_0)$

由此推出$x=y_0,y=x_0-\left\lfloor\frac{a}{b}\right\rfloor y_0$

我们可以发现，$x_0,y_0$所在的方程组的系数为$a,a\bmod b$，很容易发现这刚好对应辗转相除法，所以最后一定会以$a=gcd(a,b),b=0$结束，此时$x,y$可以为任意整数$(x\ne 0)$，这就是最终的$x_0,y_0$，我们就可以由此推出该方程的解。

<h4 id="类欧几里得">类欧几里得</h4>

用于求解形如$\sum\limits_{i=0}^n\left\lfloor\dfrac{ai+b}{c}\right\rfloor$的问题


$$
f(a,b,c,n)=\sum\limits_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor
$$

当$a=0$时


$$
f(a,b,c,d)=(n+1)\left\lfloor\frac{b}{c}\right\rfloor
$$

当$a\geqslant c$或$b\geqslant c$时


$$
f(a,b,c,n)=\sum\limits_{i=0}^n(\left\lfloor\frac{i(a\bmod c)+(b\bmod c)}{c}\right\rfloor+i\left\lfloor\frac{a}{c}\right\rfloor+\left\lfloor\frac{b}{c}\right\rfloor)
$$


$$
=f(a\bmod c,b\bmod c,c,n)+\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor+(n+1)\left\lfloor\frac{b}{c}\right\rfloor
$$

当$a<c$且$b<c$时，设$M=\left\lfloor\frac{an+b}{c}\right\rfloor$


$$
f(a,b,c,n)=\sum\limits_{i=0}^n\sum\limits_{j=1}^M[j\leqslant\left\lfloor\frac{ai+b}{c}\right\rfloor]
$$


$$
=\sum\limits_{i=0}^n\sum\limits_{j=0}^{M-1}[jc+c<ai+b+1]
$$


$$
=\sum\limits_{j=0}^{M-1}\sum\limits_{i=0}^n[i>\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor]
$$


$$
=\sum\limits_{j=0}^{M-1}(n-\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor)
$$


$$
=nM-f(c,c+b-1,a,M-1)
$$

于是有


$$
f(a,b,c,n)=\begin{cases}(n+1)\left\lfloor\frac{b}{c}\right\rfloor&a=0\\\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+f(a\bmod c,b\bmod c,c,n)&a\geqslant c\;or\;b\geqslant c\\nM-f(c,c-b-1,a,M-1),M=\left\lfloor\frac{an+b}{c}\right\rfloor&\text{otherwise}\end{cases}
$$

复杂度$O(\log n)$

<h4 id="求解同余方程组">求解同余方程组:</h4>

中国剩余定理(CRT)：

$\begin{cases}x\equiv a_1\pmod {p_1}\\x\equiv a_2\pmod {p_2}\\\cdots\\x\equiv a_n\pmod {p_n}\end{cases}$其中$p_1,p_2\cdots p_n$两两互质。

如果我们求出了$mul=\prod_{i=1}^np_i$，那么有$(\frac{mul}{p_i})\times(\frac{mul}{p_i})^{-1}\mod p_j=\begin{cases}1&i=j\\0&i\ne j\end{cases}$，于是有：<br>
$ans=\sum\limits_{i=1}^n(a_i\times(\frac{mul}{p_i})\times(\frac{mul}{p_i})^{-1}\mod p_i)\mod mul$

拓展中国剩余定理（EXCRT）：<br>
$\begin{cases}a_1x\equiv b_1\pmod{p_1}\\a_2x\equiv b_2\pmod{p_2}\\\dots\\a_nx\equiv b_n\pmod{p_n}\end{cases}$其中$p_1,p_2\cdots p_n$不互质。

我们记解决到当前方程是原答案为$x_0$,当前方程以前所有$p_i$的最小公倍数为lcm，所以当前解$x$需满足$x=x_0+tlcm$，由此得

$a(x_0+tlcm)\equiv b\pmod{p}$

$\Rrightarrow a(x_0+tlcm)+py^\prime=b$

$\Rrightarrow (alcm)t+py^\prime=b-ax_0$

$\Rrightarrow (alcm)(t\times\dfrac{gcd(alcm,p)}{b-ax_0})+p(y^\prime\times\dfrac{gcd(alcm,p)}{b-ax_0})=gcd(alcm,p)$

此时我们可以发现方程已经写成了形如$ax+by=gcd(a,b)$的形式

令$x=t\times\dfrac{gcd(alcm,p)}{b-ax_0},y=y^\prime\times\dfrac{gcd(alcm,p)}{b-ax_0}$

则方程可写为$(alcm)x+py=gcd(alcm,p)$v

而我们要求的$t$就是$x\times\dfrac{b-ax_0}{gcd(alcm,p)}$

所以可判断当$gcd(alcm,p)\nmid(b-ax_0)$时方程无解。而有解时，可以由exgcd可算出$x$（$y$没有用）,所以能求出$t=x\times\dfrac{b-ax_0}{gcd(alcm,p)}$，而新的$x_0$为$x_0+tlcm$，这时再更新$lcm=lcm\times p\div gcd(lcm,p)$

<h4 id="求解高次同余方程">求解高次同余方程</h4>

求同余方程$a^x\equiv b\pmod p(a\perp p)$

BSGS

根据欧拉定理，一定有一个小于$\varphi(p)$的根，设$P=\sqrt p$，那么$x$可以表示为$iP-j$，其中$0\leqslant i-1,j\leqslant P$，即$a^{Pi-j}\equiv b\pmod p$，也就是$a^{Pi}\equiv ba^j\pmod p$，那么只要有匹配的$a^{Pi}$和$ba^j$即可。

<h3 id="组合数">组合数</h3>

定义$C_n^m$表示从$n$个元素中选出$m$个元素的方案数，有$C_n^m=\dfrac{n!}{m!(n-m)!}$，也写作$\dbinom{n}{m}$。

递推公式：$\dbinom{n}{m}=\dbinom{n}{m-1}+\dbinom{n-1}{m-1}$

二项式定理：$(a+b)^n=\sum\limits_{i=0}^n\dbinom{n}{i}a^ib^{n-i}$

<h4 id="lucas定理">Lucas定理</h4>

对于质数$p$，有<br>
$\dbinom{n}{m}=\dbinom{\left\lfloor\frac{n}{p}\right\rfloor}{\left\lfloor\frac{m}{p}\right\rfloor}\times \dbinom{n\mod p}{m\mod p}\pmod p$

<h3 id="容斥">容斥</h3>

基本公式<br>
$|\bigcup\limits_{i=1}^na_i|=\sum\limits_{T\subseteq[1,n]}-1^{|T|+1}|\bigcap\limits_{i\in T}a_i|$

<h4 id="min-max容斥">min-max容斥</h4>

$\max_{i\in S}a_i=\sum\limits_{T\subseteq S}(-1)^{|T|+1}\min_{i\in T}a_i$

$\min_{i\in S}a_i=\sum\limits_{T\subseteq S}(-1)^{|T|+1}\max_{i\in T}a_i$

<h4 id="二项式反演">二项式反演</h4>

二项式反演用于解决“某种物品恰好若干个”这类的问题，与容斥原理类似。

一般形式：若$g_n=\sum\limits_{i=0}^n\dbinom{n}{i}f_i$，那么有$f_n=\sum\limits_{i=0}^n\dbinom{n}{i}(-1)^{n-i}g_i$

证明：将$g_i$展开，得


$$
\begin{aligned}
   f_n&=\sum\limits_{i=0}^n\dbinom{n}{i}(-1)^{n-i}\sum\limits_{j=0}^i\dbinom{i}{j}f_j\\
&=\sum\limits_{j=0}^nf_j\sum\limits_{i=j}^n\dbinom{n}{i}\dbinom{i}{j}(-1)^{n-i}\\
&=\sum\limits_{j=0}^nf_j\sum\limits_{i=j}^n\dbinom{n}{j}\dbinom{n-j}{i-j}(-1)^{n-i}\\
&=\sum\limits_{j=0}^nf_j\dbinom{n}{j}\sum\limits_{k=0}^{n-j}\dbinom{n-j}{k}(-1)^{n-j-k}\\
&=\sum\limits_{j=0}^nf_j\dbinom{n}{j}\sum\limits_{k=0}^{n-j}\dbinom{n-j}{k}(-1)^{n-j-k}1^k
&=\sum\limits_{j=0}^nf_j\dbinom{n}{j}(-1+1)^{n-j}\\
&=\sum\limits_{j=0}^nf_j\dbinom{n}{j}[n-j==0]\\
&=f_n
\end{aligned}
$$

一般的二项式反演形式有两种，一是$g_n$表示至多$n$个的方案数，$f_n$表示恰好$n$个的方案数，那么有


$$
g_n=\sum\limits_{i=0}^n\dbinom{n}{i}f_i\iff f_n=\sum\limits_{i=0}^n\dbinom{n}{i}(-1)^{n-i}g_i
$$

二是$g_n$表示至少$n$个的方案数，$f_n$表示恰好$n$个方案数，那么有


$$
g_j=\sum\limits_{i=j}^n\dbinom{i}{j}f_i\iff f_j=\sum\limits_{i=j}^n(-1)^{i-j}\dbinom{i}{j}g_i
$$

<h3 id="积性函数">积性函数</h3>

积性函数：对于任意的$\gcd(i,j)=1$，$f(i)\times f(j)=f(ij)$。

完全积性函数：对于任意的$i,j$，$f(i)\times f(j)=f(ij)$。

$\epsilon(x)=[x==1]$，$I(x)=1$，$id(x)=x$，$\sigma_k(x)=\sum\limits_{d|x}d^k$。

<h4 id="狄利克雷卷积">狄利克雷卷积</h4>

$(f*g)(n)=\sum\limits_{d|n}f(n)g(\frac{n}{d})$。

推论：

1.$\mu*I=\epsilon$

证明：当$n=1$时上式显然为1，当$n>1$时，根据唯一分解定理，设$n=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}$，根据$\mu$的定义，若$a_i>1$则$\mu(d)$为0，则$\sum\limits_{d|n}\mu(d)=\sum\limits_{i=0}^k\binom{k}{i}(-1)^i=(1-1)^k=0$

2.$\varphi*I=id$

证明：当$n=p^m$时，$\sum\limits_{d|n}\varphi(d)=\varphi(1)+\sum\limits_{i=1}^m\varphi(p^i)=1+\sum\limits_{i=1}^m(p^i-p^{i-1})=p^m=n$

当$n$为任意整数时，令$n=\prod p^m$，则$(\varphi*I)(\prod p^m)=\prod(\varphi*I)(p)=\prod p^m=n$

3.$\mu*id=\varphi$

证明：<br>
$id=\varphi*I$

$\Rrightarrow\mu*id=\varphi*(I*\mu)$

$\Rrightarrow\mu*id=\varphi*\epsilon=\varphi$

<h4 id="莫比乌斯反演">莫比乌斯反演</h4>

若<br>
$g(n)=\sum\limits_{d|n}f(d)$则<br>
$n)=\sum\limits_{d|n}\mu(d)g(\frac{n}{d})$：因为$g=(f*I)$，所以$g*\mu=f*I*\mu=f*(I*\mu)=f*\epsilon=f$

<h3 id="杜教筛">杜教筛</h3>

杜教筛是用来快速求积性函数前缀和的方法。具体来说，我们设$S(n)=\sum\limits_{i=1}^nf(i)$，再找一个积性函数$g(x)$，考虑$(f*g)$的前缀和<br>
$\sum\limits_{i=1}^n(f*g)(i)=\sum\limits_{i=1}^n\sum\limits_{d|i}f(d)g(\frac{i}{d})=\sum\limits_{d=1}^ng(d)\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}f(i)=\sum\limits_{d=1}^ng(d)S(\left\lfloor\frac{n}{d}\right\rfloor)$

我们把$g(1)S(n)$提出来，就是$g(1)S(n)=\sum\limits_{i=1}^ng(i)S(\left\lfloor\frac{n}{i}\right\rfloor)-\sum\limits_{i=2}^ng(i)S(\left\lfloor\frac{n}{i}\right\rfloor)$，我们发现，前一项$\sum\limits_{i=1}^ng(i)S(\left\lfloor\frac{n}{i}\right\rfloor)$由前面推导可知为$\sum\limits_{i=1}^n(f*g)(i)$，于是得到了杜教筛的核心式子：<br>
$g(1)S(n)=\sum\limits_{i=1}^n(f*g)(i)-\sum\limits_{i=2}^ng(i)S(\left\lfloor\frac{n}{i}\right\rfloor)$这就意味着，只要我们找到一个可以快速计算$(f*g)$的前缀和的$g(x)$，我们就可以用数论分块递归求解$S(n)$，时间复杂度是$O(n^{\frac{3}{4}})$，如果我们预处理前$n^{\frac{2}{3}}$个答案，我们就可以把复杂度降到$O(n^{\frac{2}{3}})$。

<h4 id="狄利克雷前缀和">狄利克雷前缀和</h4>

狄利克雷前缀和是一种可以在$O(n\ln\ln n)$的时间内求出序列$b$，满足$b_i=\sum\limits_{x|i}a_x$。我们可以把这个理解为高维前缀和，一个质数就是一维，因此就可以按照高维前缀和的方法来求解，即每次枚举质数$p$，然后$a_{pi}\leftarrow a_i+a_{pi}$。然后因为所有质数的倒数和是$O(\ln \ln n)$的，因此复杂度是$O(n\ln n\ln n)$的。

同样的还有狄利克雷后缀和，即$b_i=\sum\limits_{i|x}a_x$，求解的方式也就类似高维后缀和，复杂度是一样的。

<h3 id="多项式">多项式</h3>

<h4 id="拉格朗日插值">拉格朗日插值</h4>

第一步：子函数 $f_i(x)=\begin{cases}1&x=x_i\\0&x=x_j(i\ne j)\end{cases}$

由此可得：$f(x)=\sum\limits_{i=1}^ny_if_i(x)$

第二步：对于 $f_i(x)$,要满足当$x=x_i$时，$y=1$，而$x\ne x_i$时，$y=0$故:

$f_i(x)=\dfrac{\prod\limits_{j=1,j\ne i}^n(x-x_j)}{\prod\limits_{j=1,j\ne i}^n(x_i-x_j)}$

这就是拉格朗日基本多项式（插值基函数）

因此多项式第$i$项为 $y_i\times\dfrac{\prod\limits_{j=1,j\ne i}^n(x-x_j)}{\prod\limits_{j=1,j\ne i}^n(x_i-x_j)}$

所以又可以把多项式写为：

$f(x)=\sum\limits_{i=1}^ny_i\times\dfrac{\prod\limits_{j=1,j\ne i}^n(x-x_j)}{\prod\limits_{j=1,j\ne i}^n(x_i-x_j)}$

展开后为：$f(x)=\dfrac{y_1(x-x_2)(x-x_3)\cdots(x-x_n)}{(x_1-x_2)(x_1-x_3)\cdots(x_1-x_n)}+\dfrac{y_2(x-x_1)(x-x_3)\cdots(x-x_n)}{(x_2-x_1)(x_2-x_3)\cdots(x_2-x_n)}\cdots+\dfrac{y_n(x-x_1)(x-x_2)\cdots(x-x_{n-1})}{(x_n-x_1)(x_n-x_1)\cdots(x_n-x_{n-1})}$

我们可以发现，当$x=x_i$时，除了第$i$项，其余项的分子中都有一项为$(x-x_i)$，故其余项都为0，而对于第$i$项，分子中的$(x-x_j)(j\ne i)$与分母中的$(x_i-x_j)(j\ne i)$消掉了，最终只剩下了分子中的$y_i$，因此就证明了$f(x)$就是满足$f(x_i)=y_i$的多项式。

<h4 id="fft">FFT</h4>

<h5 id="1复数">1.复数</h5>

复数是形如$a+bi$的数（$i= \sqrt{-1},a,b$为实数），分为实部和虚部，并且复数可以在坐标系中表示

例如，$a+bi$可以这样表示

<img src="https://cdn.jsdelivr.net/gh/createsj-oi/figure_bed/figures/20200405211058.svg" alt="" loading="lazy">

这个用平面直角坐标系来表示复数的坐标系叫做复平面，$x$轴为实轴，$y$轴为虚轴，显然，在实轴上的点都表示实数；除了原点外，虚轴上的点都表示纯虚数。复平面内的点 $(a,b)$表示虚数$a+bi$，$a+bi$就可以表示为一个二维平面内的点$Z(a,b)$,$Z(a,b)$与向量$\overrightarrow{OZ}$唯一对应，我们把向量$\overrightarrow{OZ}$的模$r$叫做复数$z$的模，记作$\left\vert z\right\vert$，那么有：

$\left\vert z\right\vert=\left\vert a+bi\right\vert=\left\vert r\right\vert=\sqrt{a^2+b^2}$

我们常把$z=a+bi$说成点$Z$或向量$\overrightarrow{OZ}$,并规定相等的向量代表同一个复数。

当$z\ne 0$时，向量$\overrightarrow{OZ}$与实轴正方向的夹角称为复数$z$的辐角，记作$\arg z$。辐角的符号规定为：由正实轴依反时针方向转到$\overrightarrow{OZ}$为正，依顺时针方向转到$\overrightarrow{OZ}$为负。

复数相乘时，模长相乘，辐角相加。

设有两个复数$z_1=a+bi,z_2=c+di$，对应点为$A(a,b),B(c,d)$，它们的积$z_1z_2=(ac-bd)+(ad+bc)i$,对应点$C(ac-bd,ad+bc)$

模长相乘：

$\left\vert z_1z_2\right\vert=\sqrt{(ac-bd)^2+(ad+bc)^2}=\sqrt{a^2c^2+b^2d^2+a^2d^2+b^2c^2}=\sqrt{(a^2+b^2)\times(c^2+d^2)}=\left\vert z_1\right\vert\left\vert z_2\right\vert$

辐角相加：

设$P(1,0)$,连$OP,PB,AC$

$AC^2=[a-(ac-bd)]^2+[b-(ad+bc)]^2=a^2c^2+a^2d^2+b^2c^2+b^2d^2+a^2+b^2-2a^2c-2b^2c=(a^2+b^2)(c^2+d^2-2c+1)=(a^2+b^2)[(1-c)^2+(-d)^2]=OA^2PB^2$

$\therefore AC:PB=OA$

$\therefore OC:OB=OA:OP=AC:PB=OA$

$\therefore \vartriangle OAC\backsim\vartriangle OPB$

$\therefore\angle AOC=\angle BOP$

$\therefore \arg z_1z_2=\angle AOC+\angle AOP=\arg z_1+\arg z_2$

<img src="https://cdn.jsdelivr.net/gh/createsj-oi/figure_bed/figures/20200405211505.svg" alt="" loading="lazy">

<h5 id="2单位根">2.单位根</h5>

若$w^n=1$，则称$w$是$n$次单位根，在复平面上，$n$次单位根就是将单位圆等分成$n$份

<img src="https://cdn.jsdelivr.net/gh/createsj-oi/figure_bed/figures/20200405212041.svg" alt="单位圆" loading="lazy">

可以发现，$n$次单位根是且只能是辐角为$\frac{2k\pi}{n}$，即$\frac{1}{n}$圆周的复数

所以由欧拉公式$e^{i\theta}=\cos\theta+i\sin\theta$可得$w_n^k=e^{\frac{2ki\pi}{n}}=\cos\frac{2k\pi}{n}+i\sin\frac{2k\pi}{n}$

所以可得：

1.$w_{2n}^{2k}=w_n^k$

证明：$w_{2n}^{2k}=\cos\frac{2\times2k\pi}{2n}+i\sin\frac{2\times2k\pi}{2n}=w_n^k$

2.$w_n^{k+\frac{n}{2}}=-w_n^k$

证明：$w_n^{k+\frac{n}{2}}=\cos\frac{(2k+n)\pi}{n}+i\sin\frac{(2k+n)\pi}{n}=\cos(\frac{2k\pi}{n}+\pi)+\sin(\frac{2k\pi}{n}+\pi)=-\cos\frac{2k\pi}{n}+i(-\sin\frac{2k\pi}{n})=-w_n^k$

3.DFT

一个n次多项式可以由n个点值唯一确定，但朴素求这n个点值是$O(n^2)$的。<br>
设一个多项式f(x)的系数为$a_0,a_1,a_2\cdots a_{n-1}$

将f(x)按下标的奇偶性分类：<br>
$f(x)=a_0+a_2x^2+a_4x^4\cdots+a_{n-2}x^{n-2}+a_1x+a_3x^3\cdots+a_{n-1}x^{n-1}$

设$f_1(x)=a_0+a_2x+a_4x^2\cdots+a_{n-2}x^{\frac{n}{2}-1}$,

$f_2(x)=a_1+a_3x+a_5x^2\cdots+a_{n-1}x^{\frac{n}{2}-1}$

则$f(x)=f_1(x^2)+xf_2(x^2)$

我们将$w_n^k(k<\frac{n}{2})$代入得

$f(w_n^k)=f_1(w_\frac{n}{2}^k)+w_n^kf_2(w_\frac{n}{2}^k)$

将$w_n^{k+\frac{n}{2}}(k<\frac{n}{2})$代入得

$f(w_n^{k+\frac{n}{2}})=f_1(w_{n}^{2k+n})+w_n^{k+\frac{n}{2}}f_2(w_{n}^{2k+n})=f_1(w_{n}^{2k})-w_n^kf_2(w_n^{2k})$

我们发现，这两个式子只有符号不一样，因此我们算$f_1$的时候，可以$O(1)$得出$f_2$，这样问题的规模就减小了一半。

时间复杂度：

不难看出FFT是类似于线段树一样的分治算法。

因此它的时间复杂度为$O(nlogn)$

<h4 id="分治fft">分治FFT</h4>

分治FFT可以在$O(n\log^2 n)$的时间内求出满足$f_i=\sum\limits_{j=1}^if_{i-j}g_j$的$序列f$。我们发现，$f$数组在计算是需要用到之前算出来的值，不是很好直接处理，于是考虑计算每个数对后面的数的贡献。我们可以类比CDQ分治，算出$[l,mid]$对$[mid+1,r]$的贡献，然后累加起来就可以了。算贡献的一步就是直接将$f_l$到$f_{mid}$和$g_1$到$g_{r-l+1}$卷起来，单次复杂度$O(n\log n)$，因此总复杂度是$O(n\log^2 n)$的。

<h4 id="ntt">NTT</h4>

FFT的缺点在于要用到复数，对精度要求高，而且无法进行取模，这就引出了NTT。NTT运用原根代替FFT的单位根（即有一样的性质），因此在NTT时直接将原根带入即可，复杂度和FFT一样。

<h4 id="fwt">FWT</h4>

FWT即位运算卷积，用来快速计算形如$\sum\limits_{i\oplus j=k}f_ig_j$，其中$\oplus$表示某种位运算。

设 FWT(A) 是幂级数 A经过 $\rm FWT$ 变换之后得到的幂级数。

我们需要令其满足 : $A*B=C \Longleftrightarrow FWT(A)·FWT(B)=FWT(C) $(点积)。

$\rm FFT$ 是一个线性变换，我们也希望 $\rm FWT$ 变换是线性的。

我们还不知道怎么变换，于是设 $c(i,j)$为变换系数，即 $A[j]$对$FWT(A)[i] $的贡献系数。

则 $FWT(A)[i]=\sum\limits_{j=0}^{n-1}c(i,j)A_j$

由$FWT(A)*FWT(B)=FWT(C)$，得到：

$FWT(A)[i]FWT(B)[i]=FWT(C)[i]$

$\sum\limits_{j=0}^{n-1}c(i,j)A[j]\sum\limits_{k=0}^{n-1}c(i,k)B[k]=\sum\limits_{p=0}^{n-1}c(i,p)C[p]$

$\sum\limits_{j=0}^{n-1}\sum\limits_{k=0}^{n-1}c(i,j)c(i,k)A[j]B[k]=\sum\limits_{p=0}^{n-1}c(i,p)C[p]$

根据$A*B=C$得到：

$C[p]=\sum\limits_{t1\oplus t2=p}A[t1]B[t2]$

$\sum\limits_{p=0}^{n-1}c(i,p)C[p]=\sum\limits_{p=0}^{n-1}c(i,p)\sum\limits_{t1\oplus t2=p}A[t1]B[t2]$

$\sum\limits_{j=0}^{n-1}\sum\limits_{k=0}^{n-1}c(i,j)c(i,k)A[j]B[k]=\sum\limits_{p=0}^{n-1}c(i,p)\sum\limits_{t1\oplus t2=p}A[t1]B[t2]$

$\sum\limits_{j=0}^{n-1}\sum\limits_{k=0}^{n-1}c(i,j)c(i,k)A[j]B[k]=\sum\limits_{p=0}^{n-1}\sum\limits_{t1\oplus t2=p}A[t1]B[t2]c(i,t1\oplus t2)=\sum\limits_{t1=0}^{n-1}\sum\limits_{t2=0}^{n-1}A[t1]B[t2]c(i,t1\oplus t2)$

对比左右两边，我们发现只要满足$c(i,k)c(i,k)=c(i,j\oplus k)$就好了

现在，假设有了符合要求的$c$，如何优化FWT呢？

我们把$FWT(A)[i]=\sum\limits_{j=0}^{n-1}c(i,j)A[j]$按位折半，有<br>
$=\sum\limits_{j=0}^{\frac{n}{2}-1}c(i,j)A[j]+\sum\limits_{j=\frac{n}{2}}^{n-1}c(i,j)A[j]$设$i'$<br>
为$i$去掉最高位的数字，那么有<br>
$\sum\limits_{j=0}^{\frac{n}{2}-1}c(i_0,j_0)c(i',j')A[j]+\sum\limits_{j=\frac{n}{2}}^{n-1}c(i_0,j_0)c(i',j')A[j]$

$=c(i_0,0)\sum\limits_{j=0}^{\frac{n}{2}-1}c(i',j')A[j]+c(i_0,1)\sum\limits_{j=\frac{n}{2}}^{n-1}c(i,j)A[j]$

再设$A_0$下标首位为$0$的部分，如果$i_0=0$，则有：

$FWT(A)[i]=c(0,0)FWT(A_0)[i]+c(0,1)FWT(A_1)[i]\;\;\;(i\in[0,\frac{n}{2}))$

如果$i_0=1$，则有

$FWT(A)[i+\frac{n}{2}]=c(1,0)FWT(A_0)[i]+c(1,1)FWT(A_1)[i]\;\;\;(i\in[0,\frac{n}{2}))$

这就变成了一个规模为$\frac{n}{2}$的子问题。

因此关键就是c矩阵。

<strong>Or</strong>卷积：<br>
$c=\begin{bmatrix}1&0\\1&1\end{bmatrix},c^{-1}=\begin{bmatrix}1&0\\-1&1\end{bmatrix}$

即：<br>
$FWT(A)[i]=FWT(A_0)[i],FWT(A)[i+\frac{n}{2}]=FWT(A_0)[i]+FWT(A_1)[i]$<br>
$IFWT(A)[i]=IFWT(A_0)[i],IFWT(A)[i+\frac{n}{2}]=IFWT(A_1)[i]-IFWT(A_0)[i]$

<strong>And</strong>卷积：<br>
$c=\begin{bmatrix}1&1\\0&1\end{bmatrix},c^{-1}=\begin{bmatrix}1&-1\\0&1\end{bmatrix}$

即：<br>
$FWT(A)[i]=FWT(A_0)[i]+FWT(A_1)[i],FWT(A)[i+\frac{n}{2}]=FWT(A_1)[i]$<br>
$IFWT(A)[i]=IFWT(A_0)[i]-IFWT(A_1)[i],IFWT(A)[i+\frac{n}{2}]=IFWT(A_1)[i]$

<strong>Xor</strong>卷积：<br>
$c=\begin{bmatrix}1&1\\1&-1\end{bmatrix},c^{-1}=\begin{bmatrix}0.5&0.5\\0.5&-0.5\end{bmatrix}$

即：<br>
$FWT(A)[i]=FWT(A_0)[i]+FWT(A_1)[i],FWT(A)[i+\frac{n}{2}]=FWT(A_0)[i]-FWT(A_1)[i]$<br>
$IFWT(A)[i]=0.5IFWT(A_0)[i]+0.5IFWT(A_1)[i],IFWT(A)[i+\frac{n}{2}]=0.5IFWT(A_0)[i]-0.5IFWT(A_0)[i]$

<h3 id="排序不等式">排序不等式</h3>

排序不等式就是对于两个序列$a,b$，如果$a_1\leqslant a_2\leqslant \cdots\leqslant a_n,b_1\leqslant b_2\leqslant\cdots \leqslant b_n$，那么对于任意$1\sim n$的排列$p$，有


$$
\sum\limits_{i=1}^n a_ib_i\geqslant\sum\limits_{i=1}^na_ib_{p_i}\geqslant\sum\limits_{i=1}^na_ib_{n-i+1}
$$

证明：

首先有一个引理——<strong>阿贝尔变换</strong>。阿贝尔变换就是对于数列$a,b$，设$pre_i=\sum\limits_{j=1}^i b_j$，那么有


$$
\sum\limits_{i=1}^na_ib_i=a_npre_n-\sum\limits_{i=1}^{n-1}(a_{i+1}-a_i)pre_i
$$

通过这个式子，设$pre'_i=\sum\limits_{j=1}^ib_{p_j}$，<br>
显然有$\forall i\in[1,n]pre_i\leqslant pre'_i$，我们就有


$$
\begin{aligned}\sum\limits_{i=1}^na_ib_i-\sum\limits_{i=1}^na_ib_{p_i}&=a_npre_n-\sum\limits_{i=1}^{n-1}(a_{i+1}-a_i)pre_i-a_npre'_n+\sum\limits_{i=1}^{n-1}(a_{i+1}-a_i)pre'_i \\
&=\sum\limits_{i=1}^{n-1}(a_{i+1}-a_i)(pre'_i-pre_i)\geqslant 0\end{aligned}
$$

于是就证明了$\sum\limits_{i=1}^n a_ib_i\geqslant\sum\limits_{i=1}^na_ib_{p_i}$，后一个不等式的证明同理。

