# 计算理论导论笔记


<h1 id="计算理论导论">计算理论导论</h1>

<h2 id="正则语言和自动机regular-languages-and-automata">正则语言和自动机（Regular Languages and Automata）</h2>

<h3 id="dfa">DFA</h3>

确定性有限状态自动机（Deterministic Finite state Automata/DFA）由一个五元组 $(Q,\Sigma,\delta,q_0,F)$ 唯一确定。

<ul>
<li>$Q$ 为状态集合。</li>
<li>$\Sigma$ 为字符集。</li>
<li>$\delta:Q\times\Sigma\to Q$ 为状态转移函数。</li>
<li>$q_0$ 初始状态。</li>
<li>$F\sube Q$ 为可接受状态集（accept states）。</li>
</ul>

令 $A$ 为机器 $M$ 接受的所有串的集合，称 $A$ 是机器 $M$ 的语言（Language），或者称 $M$ 接受/承认 $A$，记作 $\mathrm{L}(M)=A$。

<h3 id="正则语言">正则语言</h3>

对于某个语言，如果存在某个机器承认它，那么我们称其为正则语言（Regular Language）。

可以证明，所有正则语言的集合关于交集、并集、补集、笛卡尔积、级联（Concatenation）运算、闭包（star）操作封闭。

级联：$A\circ B=\{ab|a\in A,b\in B\}$。

闭包操作：$A^{*}=\{x_1x_2\cdots x_k|k\ge 0,x_i\in A\}$。

<h3 id="nfa">NFA</h3>

非确定性有限状态自动机（Non-deterministic Finite state Automata/NFA）也可以由一个五元组 $(Q,\Sigma,\delta,q_0,F)$ 唯一确定。

<ul>
<li>$Q$ 为状态集合。</li>
<li>$\Sigma$ 为字符集。（记 $\Sigma_{\epsilon}=\Sigma\cup \{\epsilon\}$）</li>
<li>$\delta:Q\times\Sigma_{\epsilon}\to \mathcal{P}(Q)$ 为状态转移函数，其中 $\mathcal{P}(\cdot)$ 为幂集。</li>
<li>$q_0$ 初始状态。</li>
<li>$F\sube Q$ 为可接受状态集（accept states）。</li>
</ul>

$N=(Q,\Sigma,\delta,q_0,F)$，则串 $w=w_1w_2\cdots w_n(w_i\in \Sigma)$ 被 $N$ 接受当其可以被视作 $w_1w_2\cdots w_m((w_i\in \Sigma_{\epsilon}))$ $Q$ 中存在状态序列 $r_0,r_1,\dots,r_m$ 满足 $r_0=q_0$，$r_{i+1}\in \delta(r_i,w_{i+1}),\forall 0\le i\le n-1$，$r_m\in F$。这里的 $\epsilon$ 为空字符。NFA 同样也有其对应的语言。

显然 NFA 是 DFA 的扩展。同时可以证明对于每个 NFA $(Q,\Sigma,\delta,q_0,F)$，存在和其识别语言相同的 DFA $(Q',\Sigma',\delta',q_0',F')$。

先不考虑 $\epsilon -$ 边，考虑到每一个字符前缀在 NFA 上对应的可能能跳到的节点都是 $Q$ 的一个子集，于是我们直接令 $Q'=\mathcal{P}(Q)$，然后 $\forall S\in Q',a\in \Sigma$，令 $\delta'(S,a)=\bigcup_{s\in S}\delta(s,a)$，接着取 $q_0'=\{q_0\}$，最后令 $F'=\{S\in Q'|\exist s\in S,s\in F\}$。

如果加上 $\epsilon -$ 边差不多，取 $E(S)$ 为 $S$ 可以通过 $0$ 或更多 $\epsilon -$ 边到达的状态集，取 $\delta'(S,a)=\bigcup_{s\in S}E(\delta(s,a))$，$q_0'=E(\{q_0\})$ 即可。

<h3 id="正则表达式">正则表达式</h3>

$R$ 是正则表达式（Regular Expressions）如果 $R$ 是（下面 $R_1,R_2$ 是一些正则表达式）：

<ol>
<li>一个字符 $a(a\in \Sigma)$ 的集合</li>
<li>长度为 $0$ 的字符 $\epsilon$</li>
<li>$\varnothing$</li>
<li>$R_1\cup R_2$</li>
<li>$R_1\circ R_2$</li>
<li>$R_1^{*}$</li>
</ol>

定理：一个语言正则当且仅当存在正则表达式描述它。

则表达式描述的一定是正则语言：按照正则语言的定义构造 DFA 即可。

正则语言一定可以用正则表达式描述，这个证明有点复杂。

首先我们引入推广性确定性有限自动机（GNFA），区别在于每条边上除了可能是空字符 $\epsilon$、字符集中字符，还有可能是一个正则表达式。然后整个构造方法大概就是由 NFA 不断缩小，最后只剩下两个状态为止，此时即找到该正则语言对应的正则表达式。

对于一个 DFA，我们先通过一些简单的处理让其变成 NFA，同时只有一个初始节点与接受节点，且初始节点没有入边，接受节点没有出边。删减过程就是每次选择一个非初始节点并且非接受节点的节点 $x$，然后对于每对节点 $s,t$，更新 $s\to t$ 的边为 $(s\to t)\cup(s\to x)\circ(x\to x)^{*}\circ(x\to t)$，接着删掉 $x$。重复该过程直到只剩下初始节点与接受节点，此时它们之间的边即为正则语言对应的正则表达式。

<h3 id="非正则语言">非正则语言</h3>

泵引理（Pumping Lemma）：如果 $A$ 是正则语言，那么存在 $p$ 满足，对于任意长度大于等于 $p$ 的 $A$ 中字符串 $s$，$s$ 总能切成三部分 $s=xyz$ 满足 $\forall i\ge 0,xy^iz\in A,|y|>0,|xy|\le p$。（直观来说就是存在循环节，这个比较好证，由状态有限，直接取 $p=|Q|$ 即可，总有一个状态被经过了至少两次）

<h2 id="上下文无关语言和下推自动机context-free-languages-and-pushdown-automata">上下文无关语言和下推自动机（Context Free Languages and Pushdown Automata）</h2>

<h3 id="上下文无关语言cfl">上下文无关语言（CFL）</h3>

上下文无关语法是一个四元组 $(V,\Sigma,R,S)$，其中：

<ol>
<li>$V$ 是一个叫做变量（variables）的有限集合。</li>
<li>$\Sigma$ 是一个和 $V$ 不相交的有限集合，叫做终结符（terminals）集合。</li>
<li>$R$ 是一个规则（rules）的有限集，每条规则把一个变量映射成一个变量和终结符的字符串。</li>
<li>$S\in V$ 是开始变量。</li>
</ol>

令 $u,v,w$ 是变量和终止符组成的字符串，如果 $A\to w$ 是该语法的一条规则，那么我们称 $uAv$ 可以产生（yields）$uwv$，记作 $uAv\Rightarrow uwv$。称 $u$ 可以产生（derives）$v$，同样记作 $u\Rightarrow v$，当 $u=v$ 或者存在序列 $u_1,u_2,\dots,u_k(k\ge 0)$ 满足 $u\Rightarrow u_1\Rightarrow u_2\Rightarrow \cdots \Rightarrow v$。

那么所有可以由 $S$ 产生的字符串集合称作该语法的语言。

<h3 id="下推自动机pda">下推自动机（PDA）</h3>

下推自动机由六元组 $(Q,\Sigma,\Gamma,\delta,q_0,F)$ 组成，其中：

<ol>
<li>$Q$ 状态集。</li>
<li>$\Sigma$ 输入字符集。</li>
<li>$\Gamma$ 堆栈字符集。</li>
<li>$\delta:Q\times \Sigma_{\epsilon}\times \Gamma_{\epsilon}\to \mathcal{P}(Q\times \Gamma_{\epsilon})$ 转移函数。</li>
<li>$q_0\in Q$ 起始状态。</li>
<li>$F\sube Q$ 接受状态集。</li>
</ol>

一个字符串 $w$ 可以被下推自动机 $M=(Q,\Sigma,\Gamma,\delta,q_0,F)$ 接受当 $w$ 可以被视作 $w_1,w_2,\dots,w_m(w_i\in \Sigma_{\epsilon})$，并且存在状态序列 $s_0,s_1,s_2,\dots,s_m$ 和字符串 $t_1,t_2,\dots,t_m$ 满足：

<ol>
<li>$s_0=q_0$ 并且 $t_0=\epsilon$。</li>
<li>对于 $i=0,1,\dots,m-1$，满足 $(s_{i+1},b)\in \delta(s_i,w_{i+1},a)$，其中 $t_i=ar,t_{i+1}=br$ 并且 $a,b\in \Gamma_{\epsilon},r\in \Gamma^*$。</li>
<li>$s_m\in F$。</li>
</ol>

<h3 id="两者关系">两者关系</h3>

上下文无关语言和下推自动机的计算能力是一样的。

从语言到自动机：一个很简单的想法就是考虑展开规则是有限的，所以直接用堆栈描述当前历史所有在展开哪个规则以及展开到哪一步即可。

从自动机到语言：

我们可以很简单地修改 PDA 使得接受状态只有一个，且最后栈弹空，且栈只存在加入和删除，不存在替换。

$P=(Q,\Sigma,\Gamma,\delta,q,\{q_a\}),G=(V,\Sigma,R,S)$，取 $V=\{A_{p,q}|p,q\in Q\}$，取三条规则。

<ol>
<li>$\forall p,q,r,s\in Q,u\in \Gamma,a,b\in \Sigma_{\epsilon}$，若 $\delta(p,a,\epsilon)\ni (r,u),\delta(s,b,u)\ni (q,\epsilon)$，加入规则 $A_{p,q}\Rightarrow aA_{r,s}b$。</li>
<li>$\forall p,q,r\in Q$，加入规则 $A_{p,q}\Rightarrow A_{p,r}A_{r,q}$。</li>
<li>$\forall p\in Q$，加入规则 $A_{p,p}\Rightarrow \epsilon$。</li>
</ol>

取 $S=A_{q,q_a}$。

<h3 id="cfl-的边界">CFL 的边界</h3>

Pumping Lemma for CFLs：如果 $A$ 是 CFL，那么存在 $p$ 满足如果 $s\in A$ 且 $|s|\ge p$，那么 $s$ 可以被切分为五个部分 $uvxyz$ 满足 $\forall i\ge 0,uv^ixy^iz\in A$ 且 $|vy|>0,|vxy|\le p$。

怎么证明：考虑 CFL 按照语法构造过程中形成的树结构，树只要足够大必然存在两个相同的变量出现在一条直上直下的路径上，那么用上面的变量树替换下面的变量树即可造成重复。

举例：$\{a^nb^nc^n|n\in \mathbb{N}\},\{ww|w\in \{0,1\}^*\}$ 不是上下文无关模型。

<h2 id="图灵机">图灵机</h2>

<h3 id="图灵机turing-machinetm">图灵机（Turing Machine/TM）</h3>

$k$ 纸带图灵机是一个七元组 $(Q,\Sigma,\Gamma,\delta,q_0,q_{accept},q_{reject})$：

<ol>
<li>$Q$ 状态集，$\Sigma$ 输入字符集，$\Gamma$ 纸带字符集。</li>
<li>$\delta:Q\times \Gamma^k\to Q\times \Gamma^k\times \{L,S,R\}^k$。</li>
<li>$q_0$ 开始状态，$q_{accept}$ 接受状态，$Q_{reject}$ 拒绝状态。</li>
</ol>

可以看成是一个布尔函数。

当前状态 $q;x=(x_1,\dots,x_k)$，一次转移步骤 $\delta(q,x)=(q',x',z),z\in \{L,S,R\}^k$。

一个格局（configuration）：当前状态，纸带内容，当前纸带头位置。

进入 $q_{accept},q_{reject}$ 停机。

<h3 id="可识别-可判定">可识别 可判定</h3>

如果一个语言可以被图灵机 $M$ 识别，就称其是可识别的（recognizable），然而还是有可能存在输入使得 $M$ 无法停机。

如果一个图灵机 $M$ 从来不会死循环就称其可以判定一个语言，继而有可判定的（decidable）定义。

对于一个函数 $f:\{0,1\}^*\to \{0,1\}^*$，称 $M$ 计算 $f$ 如果对于任意输入 $x$，$M$ 都会进入停机状态且在输出纸带上面写了 $f(x)$。

称图灵机 $M$ 运行时间为 $T(n)$ 当对任意输入 $x$，图灵机运行不超过 $T(|x|)$ 步就会停机。

$T:\mathbb{N}\to \mathbb{N}$ 是时间可构造（time-constructible）当 $T(n)\ge n$ 且存在一个图灵机在时间 $T(n)$ 内计算 $x\rightarrow T(|x|)$。

<h3 id="大字符集">大字符集</h3>

对于任意图灵机 $M$ 在时间 $T(n)$ 内计算函数 $f$，使用纸带字符集 $\Gamma$，那么存在另一个图灵机 $M'$ 在时间 $O(T(n)\log |\Gamma|)$ 内计算函数 $f$ 而只用纸带字符集 $\{0,1,\triangle,\underline{ }\}$。

把大字符集编码即可。

<h3 id="多条纸带">多条纸带</h3>

对于任意 $k$ 条纸带图灵机 $M$ 在时间 $T(n)$ 内计算函数 $f$，那么存在另一个只用一条纸带的图灵机 $M'$ 在时间 $O(kT^2(n))$ 内计算函数 $f$。

<h3 id="church-turing-thesis">Church-Turing Thesis</h3>

任何算法等价于一个图灵计算过程。

<h3 id="通用图灵机universal-tm">通用图灵机（Universal TM）</h3>

存在一个通用图灵机可以模拟任何图灵机运行。

存在一个图灵机满足 $\forall x.\alpha\in \{0,1\}^*,U(x,\alpha)=M_{\alpha}(x)$，其中 $\alpha$ 代表了图灵机 $M_{\alpha}$，如果对于某个输入 $x$，$M_{\alpha}$ 运行了 $T$ 步停机，那么 $U(x,\alpha)$ 运行了 $CT\log T$ 步停机，其中 $C$ 是取决于 $M_{\alpha}$ 的一个常数。

<h2 id="图灵机的能力">图灵机的能力</h2>

存在不能被任何图灵机计算的布尔函数吗？

存在不能被任何图灵机识别/判定的语言吗？

存在能被图灵机识别但是不能被判定的语言吗？

<h3 id="可计算性">可计算性</h3>

<h4 id="_">$\mathrm{UC}$</h4>

定义一个布尔函数 $\mathrm{UC}:\{0,1\}^*\to \{0,1\}$，对于任意输入 $\alpha$，设 $\alpha$ 表示的图灵机为 $M_{\alpha}$，那么如果 $M_{\alpha}(\alpha)=1$ 表示 $M_{\alpha}$ 接受字符串 $\alpha$，那么我们取 $\mathrm{UC}(\alpha)=0$（拒绝），否则我们取 $\mathrm{UC}(\alpha)=1$（接受）。

那么 $\mathrm{UC}$ 就是不可计算，其对应的语言就是不可判定的。

证明：假设存在图灵机 $M$ 计算 $\mathrm{UC}$，令 $<M>$ 为 $M$ 的字符串表示，那么有 $\mathrm{UC}(<M>)=M(<M>)$ 而 $\mathrm{UC}(<M>)\ne M(<M>)$ 矛盾。

<h4 id="_-1">$\mathrm{HALT}$</h4>

考虑语言 $\mathrm{HALT}=\{<M,\alpha>|M\text{ halts on }\alpha\}$，那么该语言是不可判定的。（PS：该语言是可识别的，考虑直接模拟将 $\alpha$ 输入 $M$。）

考虑反证法，假设存在这样一个判定该语言的图灵机 $M_{\mathrm{HALT}}$，那么对于任意字符串 $\alpha$ 定义的图灵机 $M_{\alpha}$，考虑用 $<M_{\alpha},\alpha>$ 输入 $M_{\mathrm{HALT}}$，如果被接受了，说明不会死循环，然后直接模拟可以得出 $M_{\alpha}(\alpha)$ 取反，否则输出 $1$，由此我们通过该图灵机构造出了一个计算 $\mathrm{UC}$ 的图灵机，矛盾。

<h4 id="_-2">$A_{\mathrm{TM}}$</h4>

考虑语言 $A_{\mathrm{TM}}=\{<M,\alpha>|M\text{ accepts }\alpha\}$，那么该语言不可判定。

同样用判定语言 $A_{\mathrm{TM}}$ 的图灵机 $M_A$ 构造 $M_{\mathrm{UC}}$，对于输入 $\alpha$ 取 $M_A(\alpha,\alpha)$ 即可。

<h3 id="映射归约">映射归约</h3>

对于两个问题 $A,B$，我们将 $A$ 规约成 $B$ 来解决 $A$，可以先解决 $B$ 然后用这个解决方法解决 $A$。

我们称一个语言 $A$ 可以被映射归约（mapping reducible）到语言 $B$，记作 $A\le_m B$，如果存在一个可计算的函数 $f:\Sigma^*\to \Sigma^*$ 满足 $\forall w,w\in A$ 当且仅当 $f(w)\in B$。

如果 $A\le_m B$，那么：$B$ 可判定 $\Rightarrow$ $A$ 可判定，$A$ 不可判定 $\Rightarrow$ $B$ 不可判定。

<h4 id="_-3">$E_{\mathrm{TM}}$</h4>

考虑语言 $E_{\mathrm{TM}}=\{<M>|M \text{ accepts nothing}\}$，那么该语言不可判定。

考虑证明 $A_{\mathrm{TM}}\le_m E_{\mathrm{TM}}$ 或者 $A_{\mathrm{TM}}\le_m \overline{E_{\mathrm{TM}}}$。

<h4 id="_-4">$EQ_{\mathrm{TM}}$</h4>

考虑语言 $EQ_{\mathrm{TM}}=\{<M_1,M_2>|M_1 \text{ and }M_2 \text{ are TMs and } L(M_1)=L(M_2)\}$，那么该语言不可判定。

考虑证明 $E_{\mathrm{TM}}\le_m EQ_{\mathrm{TM}}$。

<h3 id="回顾">回顾</h3>

$A$ 可识别不等价于 $\overline{A}$ 可识别。

$A$ 可判定等价于 $\overline{A}$ 可判定。

定理：$A$ 可判定等价于 $A$ 可识别且 $\overline{A}$ 可识别。

<h2 id="时间复杂性time-complexity">时间复杂性（Time Complexity）</h2>

<h3 id="复杂性类">复杂性类</h3>

复杂性类：可以由一定量的计算资源计算的问题（语言）构成的集合。

定义时间函数 $T:N\to N$ 任意函数，定义 $\mathrm{DTIME}(T(n))$ 为可以被某些图灵机在 $O(T(n))$ 时间内解决的问题（判定的语言集合）。

多项式时间复杂性类 $\mathrm{P}=\cup_{c\ge 0}\mathrm{DTIME}(n^c)$。

考虑两个时间可构造函数 $f,g$，若 $f(n)=o(g(n))$，则显然 $\mathrm{DTIME}(f(n))\sube \mathrm{DTIME}(g(n))$。能否构造语言 $A$ 使得 $A\in \mathrm{DTIME}(g(n))$ 而 $A\notin \mathrm{DTIME}(f(n))$？

考虑构造图灵机 $M$：对于任意输入 $x$，取 $x$ 对应的图灵机 $M_x$，在 $O(g(n))$ 时间内模拟 $M_x(x)$，如果结果是 $1$ 输出 $0$，否则输出 $1$。那么显然 $\mathrm{L}(M)\in \mathrm{DTIME}(g(n))$。如果 $\mathrm{L}(M)\in \mathrm{DTIME}(f(n))$，那么存在图灵机 $M'$ 在时间 $O(f(n))$ 内判定 $\mathrm{L}(M)$，$M'$ 的字符串表示为 $<M'>$ 则有 $M'(<M'>)=M(<M'>)$ 矛盾。

多项式时间可验证复杂性类 $\mathrm{NP}$，一个语言 $L$ 属于 $\mathrm{NP}$ 当存在多项式函数 $P:N\to N$ 和一个多项式时间图灵机 $M$ 满足对于任意 $x\in \{0,1\}^*$，$x\in L$ 当且仅当 $\exist u\in \{0,1\}^{P(|x|)}$ 满足 $M(x,u)=1$。此时也称 $M$ 是 $L$ 的验证机（verifier），$u$ 被称作 $x$ 的验证（certificate）。

定义 $\mathrm{EXP}=\cup_{c\ge 0}\mathrm{DTIME}(2^{n^c})$，则有 $\mathrm{P}\sube \mathrm{NP}\sube \mathrm{EXP}$。已经有证明 $\mathrm{P}\subsetneq \mathrm{EXP}$。

<h3 id="非确定性图灵机">非确定性图灵机</h3>

$\mathrm{NP}$ 的最初定义是由非确定性图灵机（non-deterministic Turing machine/NDTM）引入的，NDTM 和 TM 的区别在于对于每个格局有多种可能的转移，只要存在一个分支接受一个输入即认为接受，只有所有分支都不接受即认为不接受。

同样类似地，我们可以定义在所有可能输入的所有分支都会停机的 NDTM 为判定机（decider），对于一个函数 $T:N\to N$，称一个 NDTM 运行时间为 $T(n)$ 如果对于任意长度为 $n$ 的输入，其所有分支都在 $T(n)$ 步骤内停机。

同样地，对于 $T:N\to N$，$\mathrm{NTIME}(T(n))$ 为可以被某些非确定性图灵机在 $O(T(n))$ 时间内解决的问题（判定的语言集合）。则有 $\mathrm{NP}=\cup_{c\ge 0}\mathrm{NTIME}(n^c)$。

两种 $\mathrm{NP}$ 的定义等价直接考虑验证 $u$ 与不确定性的关系即可。

<h3 id="多项式时间规约">多项式时间规约</h3>

两者关系只需要考虑 $\mathrm{NP}$ 中最难的那一类问题，使用归约的思想来定义难度。不过这里考虑的是时间复杂性，所以我们需要对归约过程做一点修改，就是在研究两种复杂性类的时候，归约过程不应该比其中更容易的复杂性类更复杂。在比较 $\mathrm{P}$ 和 $\mathrm{NP}$ 过程中，规约过程应该只考虑多项式时间归约（Polynomial Time Reduction）。

多项式时间归约：称 $A$ 可以多项式时间归约到 $B$，写作 $A\le_p B$ 当存在一个多项式时间可计算函数 $f:\Sigma^*\to \Sigma^*$ 满足 $\forall w,w\in A\Leftrightarrow f(w)\in B$。

<h3 id="-和-">$\mathrm{NP-hard}$ 和 $\mathrm{NP-complete}$</h3>

语言 $L$ 被称作是 $\mathrm{NP-hard}$ 当且仅当 $\forall A\in\mathrm{NP},A\le_pL$。语言 $L$ 被称作是 $\mathrm{NP-complete}$ 当且仅当 $L$ 是 $\mathrm{NP-hard}$ 且 $L\in NP$。

由此我们可以得出，对于 $\mathrm{NP-complete}$ 中的任意语言 $L$，$L\in P$ 等价于 $\mathrm{P}=\mathrm{NP}$。由此我们只需要研究 $\mathrm{NP-complete}$ 的那些语言。

<h3 id="布尔表达式boolean-formulas与-">布尔表达式（Boolean formulas）与 $\mathrm{3SAT}$</h3>

变量 $u_1,u_2,\dots,u_n$ 的布尔表达式 $\varphi$ 由这些变量和三个逻辑运算符 $\land,\lor,\lnot$ 组成，$\lnot u$ 也可用 $\overline{u}$ 表示。$\varphi$ 也可以被视作一个布尔函数 $\{0,1\}^n\to \{0,1\}$。

文字（literal）是一个原子公式（的肯定）（positive）或一个原子公式的否定（negative），分别可以称作是文字和否文字。

析取（Disjunctive）类似或，析取子句（Disjunctive clause）是仅由或运算符/析取操作连接起来的文字组成的布尔表达式。

合取（Conjunctive）类似与，合取子句（Conjunctive clause）是仅由与运算符/合取操作连接起来的文字组成的布尔表达式。

$\varphi$ 是合取范式（CNF/Conjunctive Normal Form）当它是由若干析取语句的合取操作组成，形如 $\land_i(\lor_j v_{i,j})$。同样有析取范式（DNF/Disjunctive Normal Form）由若干合取语句的析取操作组成。这两个都是命题公式（propositional formula）的标准形式。

$k$CNF 指每个语句只有 $\le k$ 个文字。

Cook-Levin Theorem：定义语言 $\mathrm{SAT}$ 由所有可满足的 CNF 语句组成；语言 $\mathrm{3SAT}$ 由所有可满足的 $3$CNF 语句组成。则二者都是 $\mathrm{NP-complete}$ 的。

$\mathrm{SAT}\in\mathrm{NP}$：其验证即为一组合法的赋值。

$\forall L\in \mathrm{NP},L\le_p\mathrm{SAT}$：考虑验证机 $M$ 的计算过程，使用长度为多项式级别的 CNF 表达式描述。

$\mathrm{SAT}\le_p\mathrm{3SAT}$ 知 $\mathrm{3SAT}\in\mathrm{NP-complete}$。

<h3 id="更多--相关例子">更多 $\mathrm{NP}$ 相关例子</h3>

<h4 id="独立集independent-set">独立集（Independent Set）</h4>

$\mathrm{INDSET}$ 判断图 $G$ 是否有大小为 $k$ 的独立集，则 $\mathrm{INDEST}\in \mathrm{NP-complete}$。

$\mathrm{INDSET}\in \mathrm{NP}$：验证为点集。

$\mathrm{3SAT}\le_p \mathrm{INDSET}$：考虑 $\mathrm{3SAT}$ 中的每一个子句，共有 $2^3-1$ 种合法的状态，而且只有其中一个状态能够存在，于是连一个大小为 $7$ 的团，而对于团外的任意两个状态，如果其冲突则连一条边，然后看是否有子句数量那么多的独立集即可。

<h4 id="点覆盖vertex-cover">点覆盖（Vertex Cover）</h4>

$\mathrm{Vertex-Cover}$ 判断图 $G$ 是否有大小为 $k$ 的点覆盖，则 $\mathrm{Vertex-Cover}\in \mathrm{NP-complete}$。

$\mathrm{Vertex-Cover}\in \mathrm{NP}$：验证为点集。

$\mathrm{INDSET}\le_p\mathrm{Vertex-Cover}$：有大小为 $k$ 的点覆盖，取反得到大小为 $n-k$ 的独立集。

<h4 id="01整数规划01-integer-programming">0/1整数规划（0/1 Integer Programming）</h4>

$\mathrm{IPROG}$ 给定 $m$ 个有理数系数的线性约束，判断是否有合法的给每个变量赋 $\{0,1\}$ 满足每个约束的方法，则 $\mathrm{IPROG}\in \mathrm{NP-complete}$。

$\mathrm{IPROG}\in \mathrm{NP}$：验证为一种合法赋值。

$\mathrm{SAT}\le_p\mathrm{IPROG}$：析取子句每个文字和大于等于 $1$ 即可。

<h4 id="哈密顿路径hamiltonian-path">哈密顿路径（Hamiltonian Path）</h4>

$\mathrm{dHAMPATH}$ 判断有向图是否有哈密顿路径，则 $\mathrm{dHAMPATH}\in \mathrm{NP-complete}$。

$\mathrm{dHAMPATH}\in \mathrm{NP}$：验证是路径顺序。

$\mathrm{SAT}\le_p\mathrm{dHAMPATH}$：对于任意的 $n$ 个变量 $m$ 个子句的 $\mathrm{SAT}$，每个变量构造 $2m+2$ 个点按顺序排列，相邻点连双向边，经过这些点时使用从左到右表示该变量取 $1$，从右到左表示该变量取 $0$。然后额外有开始点和结束点，接着我们按任意顺序确定每个变量的取值，也即将前一个变量的两个端点都连到下一个变量的两个端点，开始点和结束点同样如此操作，接着对于每个限制构造一个点，如果限制 $j$ 包含了 $u_i$，那么将第 $i$ 个变量的第 $2j$ 个点连到限制 $j$ 的点再连到第 $i$ 个变量的第 $2j+1$ 个点，而如果包含 $\lnot u_i$ 则反着来。不妨认为这里的第 $2j$ 个点和第 $2j+1$ 个点互为匹配点。

首先如果存在合法赋值那么如此按照顺序走即可。

如果构造的图存在哈密顿回路，那么我们可以证明其必然是按照顺序走的，如果有通过限制构造的点跳跃的情况那么其匹配点只和一个额外点连接，就必须是结束点，矛盾，所以按照走的顺序依次给每个变量赋值即可。

同样有 $\mathrm{dHAMCYCLE}$ 哈密顿环（Hamiltonoian Cycle），哈密顿路径很容易归约到哈密顿环（添加一个超级点连向所有点且被所有点连），所以也是 $\mathrm{NP-complete}$。

而无向图的情况容易变为有向图。

旅行商问题（TSP/Traveling Salesman）是否有长度小于等于 $k$ 的经过所有点的方案，显然可以由哈密顿路径归约。

<h4 id="_-5">$\mathrm{coNP}$</h4>

语言 $L\in \mathrm{coNP}$ 当 $\lnot L\in \mathrm{NP}$，有 $\mathrm{P}\sube \mathrm{NP}\cap \mathrm{coNP}$。

另一种定义方式；语言 $L\in \mathrm{coNP}$ 当存在多项式函数 $P:N\to N$ 和多项式时间图灵机 $M$ 满足对于任意 $x\in \{0,1\}^*$，有 $x\in L$ 当且仅当 $\forall u\in \{0,1\}^{P(|x|)}$ 有 $M(x,u)=0$。

类似的，我们有 $\mathrm{coNP-complete}$，且 $\lnot \mathrm{SAT}\in\mathrm{coNP-complete}$。

<h4 id="_-6">$\mathrm{NEXP}$</h4>

$\mathrm{NEXP}=\cup_{c\ge 0}\mathrm{NTIME}(2^{n^c})$。

有 $\mathrm{P}\sube \mathrm{NP}\sube\mathrm{EXP}\sube \mathrm{NEXP}$。

如果 $\mathrm{P}=\mathrm{NP}$，我们可以推出 $\mathrm{EXP}=\mathrm{NEXP}$。

<h2 id="空间复杂性space-complexity">空间复杂性（Space Complexity）</h2>

类似时间复杂性，在图灵机中，使用过的工作纸带格子（work tapes，注意输入纸带格子不算在内）被称作使用过的空间。定义函数 $S:N\to N$，如果图灵机 $M$ 对于任意长度 $n$ 的输入最多使用 $S(n)$ 个工作纸带格子，那么我们可以称 $M$ 运行空间消耗为 $S(n)$。

称语言 $L\in\mathrm{SPACE(S(n))}$ 当存在图灵机 $M$ 在空间 $S(n)$ 判定 $L$；类似的称 $L\in\mathrm{NSPACE(S(n))}$ 当存在非确定性图灵机 $M$ 在空间 $S(n)$ 判定 $L$。特别的要求 $S(n)$ 可以在 $S(n)$ 空间内计算。

由于不考虑输入纸带格子，所以 $S(n)<n$，然而一般要求 $S(n)\ge \log n$ 因为要记录读到哪里了。

定理：$\mathrm{DTIME}(S(n))\sube \mathrm{SPACE}(S(n))\sube \mathrm{NSPACE}(S(n))\sube \mathrm{DTIME}(2^{O(S(n))}) $。

<h3 id="格局图configuration-graph">格局图（Configuration Graph）</h3>

回忆图灵机的格局：状态，纸带头位置，所有的纸带内容。

对于一个空间 $S(n)$ 的图灵机，工作纸带内容最多 $S(n)$ 有用。

对于任意空间 $S(n)$ 的（非确定性）图灵机 $M$ 和输入 $x\in \{0,1\}^*$，其对应的格局图是一个有向图，其中每个节点对应 $M$ 的所有可能的格局，从格局 $C$ 到 $C'$ 有边当且仅当根据 $M$ 的转移函数，$C$ 可以走一步到达 $C'$，这个图记作 $G_{M,x}$。

可以修改 $M$ 使得接受格局只有一个 $C_{\text{accept}}$，则 $M$ 接受输入 $x$ 当且仅当 $G_{M,x}$ 中存在一条从 $C_{\text{start}}$ 到 $C_{\text{accept}}$ 的有向路径。

如果 $M$ 空间为 $S(n)$，则格局图中的每一个点都可以由 $c(S(n))$ 个比特位表示，在格局图上面 bfs/dfs 可以得到 $\mathrm{NSPACE}(S(n))\sube \mathrm{DTIME}(2^{O(S(n))})$。

<h3 id="空间复杂性类">空间复杂性类</h3>

$\mathrm{PSPACE}=\cup_{c\ge 0}\mathrm{SPACE}(n^c)$。

$\mathrm{NPSPACE}=\cup_{c\ge 0}\mathrm{NSPACE}(n^c)$。

$\mathrm{L}=\mathrm{SPACE}(\log n)$。

$\mathrm{NL}=\mathrm{NSPACE}(\log n)$。

注意到 $\mathrm{NP}\sube \mathrm{PSPACE}$。

$\mathrm{PATH}=<G,s,t>$ 表示有向图 $G$ 中是否存在 $s$ 到 $t$ 的路径，那么 $\mathrm{PATH}\in \mathrm{NL}$，猜每一步往哪里走即可，而其是否属于 $\mathrm{L}$ 还是 open 的。

Space Hierarchy Theorem：如果 $f,g$ 是空间可构造的函数满足 $f(n)=o(g(n))$，那么有 $\mathrm{SPACE}(f(n))\subsetneq \mathrm{SPACE}(g(n))$。

<h3 id="-completeness">$\mathrm{PSPACE}$-Completeness</h3>

语言 $L\in \mathrm{PSPACE-hard}$ 当 $\forall L'\in \mathrm{PSPACE}$，$L'\le_p L$；如果还有 $L\in \mathrm{PSPACE}$，则称 $L\in \mathrm{PSPACE-complete}$。注意这里的 $\le_p$ 还是多项式时间归约。

带量词的布尔表达式（QBF/Quantified Boolean Formula）的正确性是 $\mathrm{PSPACE-complete}$ 的。

QBF 是一个形如 $\psi=Q_1x_1Q_2x_2\dots Q_nx_n,\phi(x_1,x_2,\dots,x_n)$ 的布尔表达式，其中 $Q_i$ 是 $\forall$ 或者 $\exists$，而 $\phi$ 是一个普通的布尔表达式。

定义 $\mathrm{TQBF}$ 为所有真的 QBF，其为 $\mathrm{PSPACE-complete}$。

具体而言解决 $\mathrm{TQBF}$ 的算法就是按照顺序递归枚举 $x_i$ 的取值即可，由于空间可以重复利用所以容易发现其属于 $\mathrm{PSPACE}$。

对于任意 $L\in \mathrm{PSPACE}$，令 $M$ 为在 $S(n)$ 空间内判定 $L$ 的图灵机，考虑 $M$ 的格局图，令 $m=O(S(n))$ 为需要编码 $M$ 格局的比特数，则存在长度为 $O(m)$ 的表达式 $\phi_{M,x}$ 满足对于任意两个格局 $C,C'$，$\phi_{M,x}(C,C')=1$ 当且仅当 $C$ 走一步可以到达 $C'$。

更一般地，我们可以构造一个多项式大小的 QBF $\psi_i$ 满足对任意格局 $C,C'$，$\psi(C,C')=1$ 当且仅当 $G_{M,x}$ 存在长度不超过 $2^i$ 的 $C$ 到 $C'$ 的有向路径。

取 $\psi_0=\phi$，而 $\psi_i(C,C')=\exist C'',\psi_{i-1}(C,C'')\land \psi_{i-1}(C'',C)$，不过该转移每次大小乘以 $2$ 不够优秀，注意到：


$$
\begin{aligned}
    &\exists C'',\psi_{i-1}(C,C'')\land \psi_{i-1}(C'',C')\Leftrightarrow\\
    &\exists C'',\forall D_1,\forall D_2,((D_1=C\land D_2=C'')\lor (D_1=C''\land D_2=C'))\Rightarrow \psi_{i-1}(D_1,D_2)\Leftrightarrow
\end{aligned}

$$

而 $A=B\Leftrightarrow (A\land B)\lor (\lnot A\land \lnot B),A\Rightarrow B\Leftrightarrow \lnot A\lor B$，由此我们节省大小，记 $S_i$ 表示 $\psi_i$ 的大小，我们有 $S_i=S_{i-1}+O(m)$，进而我们找到了多项式时间归约方法。

综上 $\forall L\in\mathrm{PSPACE},L\le_p\mathrm{TQBF}$，由此 $\mathrm{TQBF}\in\mathrm{PSPACE-complete}$。

注意到上述证明没有要求 $M$ 一定要是确定性图灵机，所以同样有 $\mathrm{TQBF}\in\mathrm{NPSPACE-hard}$，进而 $\mathrm{PSPACE}=\mathrm{NPSPACE}$。

Savitch's Theorem：更加一般化地，对于任意空间可构造函数 $S:N\to N$ 满足 $S(n)\ge \log n$，有 $\mathrm{NSPACE}(S(n))\sube \mathrm{SPACE}(S(n)^2)$。

<h3 id="-和--1">$\mathrm{NL}$ 和 $\mathrm{L}$</h3>

由 Savitch's Theorem，我们知道 $\mathrm{NL}\sube \mathrm{L}^2=\mathrm{SPACE}(\log^2n)$，而 $\mathrm{NL}$ 是否等于 $\mathrm{L}$ 仍然是 open 的。

一个函数 $f:\{0,1\}^*\to\{0,1\}^*$ 是隐式对数空间可计算的（implicitly logspace computable），当：

<ol>
<li>存在常数 $c$ 满足 $\forall x,|f(x)|\le|x|^c$。</li>
<li>语言 $L_f=\{<x,i>|f(x)_i=1\}$ 和 $L_f'=\{<x,i>|i\le |f(x)|\}$ 属于 $\mathrm{L}$。这两条限制分别保证了我们可以计算 $f(x)$ 的每一位以及对于每个下标 $i$ 判断是否有 $i\le |f(x)|$。</li>
</ol>

对数空间归约（Logspace reduction）：$B$ 可以对数空间归约到 $C$，记作 $B\le_l C$，当存在隐式对数可计算函数 $f:\{0,1\}^*\to \{0,1\}^*$ 满足 $x\in B\Leftrightarrow f(x)\in C$。

使用对数空间规约，由此有 $\mathrm{NL-hard}$ 和 $\mathrm{NL-complete}$ 的定义。

由格局图容易证明 $\mathrm{PATH}\in\mathrm{NL-complete}$。

<h3 id="-和--2">$\mathrm{NL}$ 和 $\mathrm{coNL}$</h3>

回忆 $\mathrm{NL}=\mathrm{NSPACE}(\log n)$。

另一种等价定义：语言 $L\in \mathrm{NL}$ 当存在确定性图灵机 $M$（验证机）以及一个额外的仅读一次的输入纸带（这个指的是输入的验证 $u$），以及一个多项式函数 $P:N\to N$ 满足对于任意 $x$，$x\in L$ 当且仅当存在 $u\in \{0,1\}^{P(|x|)}$ 满足 $M(x,u)=1$，其中 $M$ 最多使用 $O(\log|x|)$ 额外工作纸带空间。

二者等价考虑验证和非确定性的关系即可。注意到仅读一次是因为 $\log |x|$ 的空间使得其无法记录之前所有的选择。

类似 $\mathrm{coNP}$，我们可以定义 $\mathrm{coNL}$，例如 $\lnot \mathrm{PATH}=\{<G,s,t>\}$ 满足 $G$ 中不存在 $s$ 到 $t$ 的边，由于 $\mathrm{PATH}\in \mathrm{NL-complete}$，同样有 $\lnot\mathrm{PATH}\in\mathrm{coNL-complete}$。

事实上可以证明 $\lnot\mathrm{PATH}\in\mathrm{NL}$，从而 $\mathrm{NL}=\mathrm{coNL}$。

证明考虑定义 $S_i$ 表示 $s$ 经过不超过 $i$ 条边能够到达的点集，记 $c_i=|S_i|$，那么如果图灵机已知 $c_i$，那么我们在证书中依次给出 $S_i$ 中按照编号排好序的点 $x$ 以及 $s$ 到达 $x$ 的路径，那么我们就可以验证 $x$ 确实属于 $S_i$，而我们事实上是可以通过 $c_{i}$ 推出 $c_{i+1}$ 的，具体而言就是依次枚举每个点 $y$ 判断 $y$ 是否属于 $S_{i+1}$，而判断方法依赖于证书依次给出 $S_i$ 中每个点 $x$ 以及它们的到达方法（根据编号顺序以及 $c_i$ 可以验证证书正确性），然后扫到 $x$ 的时候额外看一下是否有 $x$ 到 $y$ 的边，扫完 $S_i$ 中所有点后即可判定是否有 $y\in S_{i+1}$，不断执行 $n$ 次可以得到 $c_{i+1}$ 的大小。而我们知道 $c_0=|S_0|=|\{s\}|$，由此可以不断计算到 $c_n$，根据其以及证书给出来的 $S_n$ 即可验证 $t$ 确实不可由 $s$ 到达。

更加一般化地，有对于任意空间可构造函数 $S(n)\ge \log n$，有 $\mathrm{NSPACE}(S(n))=\mathrm{coNSPACE}(S(n))$。

总结：


$$
\mathrm{L}\sube \mathrm{NL}=\mathrm{coNL}\sube \mathrm{P}\sube \mathrm{NP}\sube \mathrm{PSPACE}=\mathrm{NPSPACE}\sube \mathrm{EXP}\sube \mathrm{NEXP}

$$

<h3 id="多项式层次结构the-polynomial-hierarchy">多项式层次结构（the Polynomial Hierarchy）</h3>

注意到一些问题形如 $\text{EXACT INDSET}$ 没有一些好的描述，不太能给出一个证书，你需要说明图 $G$ 存在一个大小为 $k$ 的独立集同时还要所有独立集大小小于等于 $k$，使用了一个存在量词和一个全称量词。

由此启发我们定义复杂性类 $\Sigma_2^p$ 表示所有语言 $L$ 满足存在多项式时间图灵机 $M$ 和一个多项式函数 $q$ 满足 $\forall x\in \{0,1\}^*$，$x\in L$ 等价于 $\exists u\in \{0,1\}^{q(|x|)}\forall v\in \{0,1\}^{q(|x|)},M(x,u,v)=1$。

由此容易发现 $\mathrm{NP}\sube \Sigma_2^p$（忽略 $v$），而 $\mathrm{coNP}\sube \Sigma_2^p$（忽略 $u$）。

类似的我们可以定义 $\Sigma_i^p$，表示的是拥有 $i$ 个以 $\exists$ 打头的交替量词证书的语言。

继续定义 $\Pi_i^p=\mathrm{co}\Sigma_i^p$，表示的是拥有 $i$ 个以 $\forall$ 打头的交替量词证书的语言。

由该定义可以看出 $\Sigma_i^p,\Pi_i^p\sube \Sigma_{i+1}^p$，$\Sigma_i^p,\Pi_i^p\sube \Pi_{i+1}^p$。我们也可以认为有 $\Sigma_{i+1}^p=\mathrm{NP}^{\Pi_i^p},\Pi_{i+1}^p=\mathrm{coNP}^{\Sigma_i^p}$，这里的 $\mathrm{NP}$ 和 $\mathrm{coNP}$ 的上角标表示的是使用的验证机所在的语言。

谕示机（Oracle TMs），又叫做预言机，类似于把一个语言当作黑箱用。具体而言谕示机有一个特殊的谕示纸带和三个特殊的状态 $q_{\text{query}},q_{\text{yes}},q_{\text{no}}$。在运行一个谕示机 $M$ 的时候首先需要指定一个语言 $O$，用作谕示 $M^O(x)$，而后在 $M$ 的运行过程中，任何时刻进入了 $q_{\text{query}}$ 状态时，当谕示纸带输入在语言 $O$ 中就会转移到 $q_{\text{yes}}$ 状态，否则转移到 $q_{\text{no}}$ 状态。

定义 $\mathrm{PH}=\cup_{i=1}^{\infty}\Sigma_i^p=\cup_{i=1}^{\infty}\Pi_i^p$，也即多项式层级（语言）。我们有定理，$\forall i$ 若 $\Sigma_i^p=\Pi_i^p$，就有 $\mathrm{PH}=\Sigma_i^p$，由此可以得到 $\mathrm{P}=\mathrm{NP}$ 蕴含着 $\mathrm{PH}=\mathrm{P}$。

一个语言 $L$ 是 $\Sigma_i^p$-complete 当 $L\in \Sigma_i^p$ 且 $\forall L'\in \Sigma_i^p$，有 $L'\le_p L$。对任意 $i$，定义 $\Sigma_i\mathrm{SAT}=\{\text{all QBFs of the form}\exist u_1\forall u_2\cdots Q_iu_i\phi(u_1,\cdots,u_i)\text{that are true}\}$，其中 $\phi()$ 是布尔表达式，那么 $\Sigma_i\mathrm{SAT}$ 就是 $\Sigma_i^p$-complete 的。

然而事实上不太可能存在 $\mathrm{PH}$-complete 的语言，因为如果存在这样的语言 $L$，由之前的定理容易推出 $\exists i$ 满足 $\mathrm{PH}=\Sigma_i^p$。

容易看出 $\mathrm{PH}\sube \mathrm{PSPACE}$。事实上如果 $\mathrm{PH}=\mathrm{PSPACE}$，那么说明 $\mathrm{TQBF}$ 是 $\mathrm{PH}$-complete 的，由此 $\mathrm{PH}$ 语言必然坍缩（collapse）在某一层级。

<h2 id="布尔电路boolean-circuits">布尔电路（Boolean Circuits）</h2>

<h3 id="基础">基础</h3>

对于任意 $n$，$n$ 输入 $1$ 输出的布尔电路是一个拥有 $n$ 个源（source，这里指的是入度为 $0$ 的点）和 $1$ 个汇（sink，这里指的是出度为 $0$ 的点）的 DAG。所有非源节点都被叫做门（gates）并且被标记为 $\lor,\land,\lnot$ 中的一个。

对于布尔电路 $C$，其大小 $|C|$ 定义为节点数量。

一个门连入边的数量叫做扇入（fan-in），而连出边的数量叫做扇出（fan-out）：对于 $\lor,\lnot$，其扇入为 $2$，而 $\lnot$ 扇入为 $1$；而布尔表达式中扇出都是 $1$，通用电路（General circuits）中扇出可以大于 $1$。

对于函数 $T:N\to N$，一个 $T(n)$ 大小的电路族是一列布尔电路 $C_1,C_2,\dots$，其中 $C_n$ 有 $n$ 个输入 $1$ 个输出，且对任意 $n$ 有 $|C_n|\le T(n)$。称一个语言 $L\in \mathrm{SIZE}(T(n))$ 如果存在 $T(n)$ 大小的电路族 $C_1,C_2,\dots$，满足对于任意 $n$ 和 $x\in \{0,1\}^n$ 有 $x\in L$ 当且仅当 $C_n(x)=1$。

一个 CNF/DNF 是一个特殊的电路。另外任意 $n$ 个比特的布尔函数都可以被大小至多 $n2^n$ 的布尔电路计算。

<h3 id="_-7">$\mathrm{P/poly}$</h3>

定义 $\mathrm{P/poly}$ 为可以被多项式大小的电路判定的语言类，也即 $\mathrm{P/poly}=\cup_{c\ge 0}\mathrm{Size}(n^c)$。

有 $\mathrm{P}\sube\mathrm{P/poly}$，证明考虑任意语言 $L$ 如果可以被 $T(n)$ 运行时间的图灵机判定，则直接看它顺序经过的 $T(n)+1$ 个格局 $C_0,\cdots,C_{T(n)}$，每一个后面的格局可以由前一个用 $O(T(n))$ 大小的 CNF 计算得到，而答案可以由 $C_{T(n)}$ 得到，于是就给出了一个 $O(T(n)^2)$ 大小的电路。

注意到如此构造电路深度同样为 $O(T(n))$，而且该电路不仅是多项式大小的，其本身也可以被一个图灵机在多项式时间内计算。这样的电路也叫做 $\mathrm{P}$-uniform circuits。

$\mathrm{P/poly}$ 中事实上存在不可判定的语言。首先任意元语言（unary language，指形如 $\{1^n|n\in S\}$ 的语言）都在 $\mathrm{P/poly}$ 内，而存在不可判定的元语言，例如定义 $\mathrm{UHALT}=\{1^n|\text{the binary expression of }n\text{ encodes a pair }<M,x>\text{ such that TM }M\text{ halts on }x\text{.}\}$，则通过计算编码知 $\mathrm{HALT}\le_m\mathrm{UHALT}$。

<h3 id="对于-cook-levin-theorem-的另一视角">对于 Cook-Levin Theorem 的另一视角</h3>

定义语言 $\mathrm{CKT-SAT}=\{\text{all circuits (string representation) that are satifiable.}\}$，则其为 $\mathrm{NP-complete}$，首先要证明 $\mathrm{NP}$ 很简单，而任取 $\mathrm{NP}$ 中语言 $L$，考虑其验证机 $M$ 和证书 $u$，直接考虑计算 $M$ 的布尔电路，相当于证书的输入端是可以任取的，也就是归约到证书任取是否有可满足的布尔电路，所以其为 $\mathrm{NP-complete}$。

考虑证明 $\mathrm{CKT-SAT}\le_p\mathrm{SAT}$，对于每条线路都定义一个变量，那么对于每个门实际上是一个等价限制 $\leftrightarrow$，诸如 $x\leftrightarrow y\lor z$ 或 $x\leftrightarrow y\land z$ 等，而这些所有的合取及转化为 $\mathrm{SAT}$。

之前定义的 $\mathrm{SAT}$ 中限制了布尔表达式形式必须是 CNF，实际上可以拓展为只需要是若干个子句的合取范式即可，每个子句内部可以使用任意的 $\lor,\land,\lnot,\rightarrow,\oplus,\leftrightarrow$。

而在将 $\mathrm{SAT}$ 归约到 $3\mathrm{SAT}$ 问题时，同样先利用等价关系把每个子句限制为三个文字，此后直接考虑每个子句 $\phi$ 其八个不同输入的真值表，有 $\lnot\phi$ 可以表示为那些输出为 $0$ 的情况合取子句的析取，而取反后为析取子句的合取，从而归约到 $3\mathrm{SAT}$。

<h3 id="布尔函数的电路大小">布尔函数的电路大小</h3>

任何 $n$ 比特布尔函数可以被最多 $n2^n$ 大小的布尔电路计算，事实上有个更小的下界，存在 $n$ 个比特的布尔函数需要 $\Omega(2^n/n)$ 大小电路。

证明直接考虑计数，$n$ 比特的布尔函数有 $2^{2^n}$ 种，而大小为 $T$ 的布尔电路最多有 $(3\binom{T}{2})^T$ 种，有 $(3\binom{T}{2})^T\ge 2^{2^n}$，有 $T=\Omega(2^n/n)$。

<h3 id="uniformly-generated-circuits">Uniformly Generated Circuits</h3>

定义：一个电路族 $\{C_n\}$ 是 $\mathrm{P}$-uniform 的当存在多项式时间图灵机 $M$，当输入为 $1^n$ 时输出为 $C_n$ 的描述。（前文有提到过）

则有定理：一个语言 $L$ 可以被 $\mathrm{P}$-uniform 电路族计算当且仅当 $L\in \mathrm{P}$。

定义：一个电路族 $\{C_n\}$ 是 logspace-uniform 的当存在对数空间图灵机 $M$ 输入 $1^n$ 时输出为 $C_n$ 的描述。

则有定理：一个语言 $L$ 有多项式大小的 logspace-uniform 电路判定当且仅当 $L\in\mathrm{P}$。

<h3 id="拥有建议advice的图灵机">拥有建议（Advice）的图灵机</h3>

定义：可以被 $T(n)$ 事件附加 $a(n)$ 比特建议的图灵机判定的语言类为 $\mathrm{DTIME}(T(n))/a(n)$。

或者说可以理解为其包含所有 $L$ 满足存在满足 $\alpha_n\in\{0,1\}^{\alpha(n)}$ 的序列 $\{\alpha_n\}$ 和图灵机 $M$ 满足 $\forall x\in \{0,1\}^n$ 有 $M(x,\alpha_n)=1$ 当且仅当 $x\in L$，并且 $M$ 运行 $O(T(n))$ 步。

有定理：$\mathrm{P/poly}=\cup_{c,d}\mathrm{DTIME}(n^c)/n^d$。

$\Rightarrow$ 考虑在建议中直接给出整个电路的描述，由此图灵机只需要模拟电路即可。

$\Leftarrow$ 和 $\mathrm{P}\sube \mathrm{P/poly}$ 类似？

<h3 id="non-uniform-size-hierarchy-theorem">Non-Uniform Size Hierarchy Theorem</h3>

直觉上来说拥有更大大小的电路族能够计算更多函数。

我们有定理：对任意函数 $T,T':N\to N$，其中 $n<T(n)<T'(n)<2^n/(100n)$ 并且 $T(n)\log^2T(n)=o(T'(n))$，我们有 $\mathrm{SIZE}(T(n))\subsetneq \mathrm{SIZE}(T'(n))$。

证明：令 $l=\log T(n)+\log \log T(n)+C$ 其中 $C$ 为足够大常数 $C>1$。通过计数知存在函数 $f:\{0,1\}^l\to \{0,1\}$ 需要电路大小 $\Omega(2^l/l)>T(n)$，所以 $f\notin\mathrm{SIZE}(T(n))$。而 $l2^l=O(T(n)\log^2T(n))=o(T'(n))$，所以 $f\in\mathrm{SIZE}(T'(n))$。由此得证。

<h3 id="karp-lipton-theorem">Karp-Lipton Theorem</h3>

Karp-Lipton Theorem：若 $\mathrm{NP}\sube \mathrm{P/poly}$，有 $\mathrm{PH}=\Sigma_2^p$。

证明过程：$\mathrm{NP}\sube\mathrm{P/poly}\Rightarrow\Pi_2\mathrm{SAT}\in\Sigma_2^p\Rightarrow\Pi_2^p\sube\Sigma_2^p\Rightarrow \mathrm{PH}=\Sigma_2^p$。

其中 $\Pi_2\mathrm{SAT}=\{\text{all QBFs of the form }\forall u,\exists v,\phi(u,v)=1\}$。

要证明 $\Pi_2\mathrm{SAT}\in\Sigma_2^p$，等价于要找到多项式时间图灵机 $M$ 和多项式函数 $q$ 满足对于任意 QBF $\psi=\forall u,\exists v,\phi(u,v)$，有 $\psi$ 为真当且仅当 $\exists u'\in\{0,1\}^{q(|x|)},\forall v'\in \{0,1\}^{q(|x|)},M(\psi,u',v')=1$。

注意到语言 $L=\{<\phi,u>,\exists v,\phi(u,v)=1\}\in \mathrm{NP}$。由假设 $\mathrm{NP}\sube\mathrm{P/poly}$ 知存在多项式大小电路族 $\{C_n\}$ 判定 $L$，也即 $\exists v,\phi(u,v)=1\Leftrightarrow C_n(\phi,u)=1$。

利用搜索到判定的归约，我们可以找到另一个多项式大小电路族 $\{C_n'\}$ 能够输出这样一个 $v$，也即 $\forall <\phi,u>$ 由 $\exists v,\phi(u,v)=1$ 当且仅当 $\phi(u,C_n'(\phi,u))=1$。

注意到 $C_n'$ 与 $u,\phi$ 无关，不妨用 $w$ 表示 $C_n'$ 的描述，为多项式大小。于是有 $\psi:=\forall u,\exists v,\phi(u,v)=1$ 当且仅当 $\exists w$ 描述 $C_n'$ 使得 $\forall u,\phi(u,C_n'(\phi,u))=1$。

由此有 $\Pi_2\mathrm{SAT}\in\Sigma_2^p$。

<h3 id="电路的深度depth">电路的深度（Depth）</h3>

电路深度与并行计算一个函数的能力相关。

定义：一个函数被称作拥有高效并行算法若对于大小 $n$ 的输入可以被拥有 $\mathrm{Poly}(n)$ 级别的处理器在 $\mathrm{Poly}\log n$ 时间内解决。

定义：一个语言在语言类 $\mathrm{NC}^i$ 当存在常数 $c>0$ 满足其可以被 logspace-uniform 大小 $O(n^c)$ 深度 $O(\log^in)$ 的电路族判定。$\mathrm{NC}=\cup_{i=1}^{\infty}\mathrm{NC}^i$

定义：一个语言在语言类 $\mathrm{AC}^i$ 当存在常数 $c>0$ 满足其可以被 logspace-uniform 大小 $O(n^c)$ 深度 $O(\log^in)$ 的电路族判定，其中电路中的 AND/OR 门可以拥有无限的扇入。$\mathrm{AC}=\cup_{i=1}^{\infty}\mathrm{AC}^i$。

对于任意 $i\ge 0$，$\mathrm{NC}^i\sube\mathrm{AC}^i\sube\mathrm{NC}^{i+1}$。

已知 $\mathrm{NC}^0\subsetneq \mathrm{AC}^0\subsetneq \mathrm{NC}^1$，其余还不确定是否为真子集。

定理：一个语言有高效并行算法当且仅当其在 $\mathrm{NC}$ 中。

<h2 id="随机计算">随机计算</h2>

<h3 id="概率图灵机probabilistic-tmptm">概率图灵机（Probabilistic TM/PTM）</h3>

概率图灵机（Probabilistic TM/PTM）是一个拥有两个转移函数 $\delta_0,\delta_1$ 的图灵机，对于输入 $x$ 的每次转移，以 $0.5$ 概率选择 $\delta_0$ 转移，以 $0.5$ 概率选择 $\delta_1$ 转移。每次选择是独立的。

PTM 也可以视作随机性是由一个额外纸带提供的。

同样地，称 $M$ 运行时间为 $T(n)$，若对任意输入 $x$，$M$ 在 $T(|x|)$ 步内停机。

对于时间函数 $T:N\to N$ 和语言 $L$，我们称一个 PTM $M$ 在时间 $T(n)$ 内判定 $L$ 当 $M$ 在 $T(|x|)$ 步内停止且 $\mathrm{Pr}[M(x)=L(x)]\ge 2/3$。

<h3 id="ptm-相关语言类">PTM 相关语言类</h3>

$\mathrm{BPTIME}(T(n))$ 为可以被 PTM 在 $O(T(n))$ 时间内判定的语言类。

定义 $\mathrm{BPP}=\cup_c\mathrm{BPTIME}(n^c)$。

$\mathrm{BPP}$ 另一种等价定义：语言 $L\in\mathrm{BPP}$ 当存在 PTM $M$ 和多项式函数 $p$ 满足对于任意 $x\in \{0,1\}^*$，有 $x\in L\Rightarrow \mathrm{Pr}_{r\sim U_{p(|x|)}}[M(x,r)=1]\ge 2/3,x\notin L\Rightarrow \mathrm{Pr}_{r\sim U_{p(|x|)}}[M(x,r)=1]< 1/3$。

$\mathrm{RTIME}(T(n))$ 包含所有语言 $L$ 满足存在 PTM $M$ 运行时间 $O(T(n))$ 且对任意 $x$：


$$
\begin{align}
    x\in L&\Rightarrow \mathrm{Pr}[M(x)=1]\ge 2/3\\
    x\notin L&\Rightarrow \mathrm{Pr}[M(x)=1]=0
\end{align}

$$

$\mathrm{RP}=\cup_{c>0}\mathrm{RTIME}(n^c)$。

$\mathrm{ZTIME}(T(n))$ 包含所有语言 $L$ 满足存在 PTM $M$ 运行时间期望 $O(T(n))$ 且对任意 $x$，当 $M$ 在 $x$ 上停机时有：


$$
\begin{align}
    x\in L&\Leftrightarrow M(x)=1\\
\end{align}

$$

$\mathrm{ZPP}=\cup_{c>0}\mathrm{ZTIME}(n^c)$。

立即有一些简单的性质 $\mathrm{BPP}=\mathrm{coBPP},\mathrm{RP}\sube \mathrm{BPP},\mathrm{coRP}\sube \mathrm{BPP},\mathrm{ZPP}=\mathrm{RP}\cap \mathrm{coRP}$。

<h3 id="误差归约error-reduction">误差归约（Error Reduction）</h3>

BPP Error Reduction Theorem：$L$ 为一个语言且存在多项式时间 PTM $M$ 满足对于任意 $x\in\{0,1\}^*$，有 $\mathrm{Pr}[M(x)=L(x)]\ge 0.5+|x|^{-c}$，则对任意常数 $d$，存在一个多项式时间 TM $M'$ 满足对于任意 $x\in \{0,1\}^*$，有 $\mathrm{Pr}[M'(x)=L(x)]\ge 1-2^{-|x|^d}$。

<h3 id="与其它复杂性类的关系">与其它复杂性类的关系</h3>

定理：$\mathrm{BPP}\sube\mathrm{P/poly}$。

取 $L\in\mathrm{BPP}$，通过 error reduction，存在 $M:\{0,1\}^n\times \{0,1\}^m\to \{0,1\}$ 满足对任意 $x\in\{0,1\}^n,\mathrm{Pr}_r[M(x,r)\ne L(x)]\le 2^{-(n+1)}$。也就是说，对于每个 $x$，至多有 $2^m/(2^{n+1})$ 个 $r$ 满足 $M(x,r)\ne L(x)$，称作是坏的 $r$。$x$ 有 $2^n$ 个，所以最多有 $2^m/2$ 个坏的 $r$，也即存在 $r\in \{0,1\}^m$ 满足 $M(x,r)=L(x)$。

定理：$\mathrm{BPP}\sube \Sigma_2^p\cap \Pi_2^p$。

由 $\mathrm{BPP}=\mathrm{coBPP}$，我们只需要证明 $\mathrm{BPP}\sube \Sigma_2^p$。

先用 error reduction，得到 $M$ 使用 $m=\mathrm{poly}(n)$ 个随机比特满足 $x\in L\Rightarrow \mathrm{Pr}_r[M(x,r)=1]\ge 1-2^{-n}$ 且 $x\notin L\Rightarrow \mathrm{Pr}_r[M(x,r)=1]\le 2^{-n}$。

取 $k=\lceil m/n\rceil +1$，考虑选取若干 $u_1,\dots,u_k\in \{0,1\}^m$，对于 $r\in \{0,1\}^m$，$\lor_{i=1}^kM(x,r\oplus u_i)$ 的含义究竟是什么。

对于 $x\notin L$，有 $\mathrm{Pr}_r[M(x,r)=1]\le 2^{-n}$，于是有 $\mathrm{Pr}_r[\exists 1\le i\le k,M(x,r\oplus u_i)=1]\le k2^{-n}<1$，也即存在 $r$ 满足 $\lor_{i=1}^kM(x,r\oplus u_i)=0$。

对于 $x\in L$，有 $\mathrm{Pr}_r[M(x,r)=0]\le 2^{-n}$，考虑 $u_1,\dots,u_k$ 均匀独立随机取，有 $\mathrm{Pr}_{u_1,\dots,u_k}[\lor_i M(x,u_i\oplus r)=0]\le 2^{-kn}<2^{-m}$。由此 $\mathrm{Pr}_{u_1,\dots,u_k}[\exists r,(\lor_i M(x,u_i\oplus r)=0)]<1$，由此存在 $u_1,\dots,u_k\in \{0,1\}^m$，满足对于任意 $r\in \{0,1\}^m$，有 $\lor_i M(x,r\oplus u_i)=1$。

于是我们得到 $x\in L$ 等价于存在 $u_1,\dots,u_k\in \{0,1\}^m$ 满足对于任意 $r\in \{0,1\}^m$ 有 $\lor_i M(x,r\oplus u_i)$ 为真。由此得证 $\mathrm{BPP}\sube \Sigma_2^p$。

<h3 id="空间相关类">空间相关类</h3>

对于 $\mathrm{PSPACE}$，没有必要尝试多项式长度的随机，毕竟可以直接枚举尝试所有可能的点。

考虑 $O(\log n)$ 的工作空间，我们有 $\mathrm{BPL}$ 和 $\mathrm{RL}$ 类，定义类似 $\mathrm{BPP}$ 和 $\mathrm{RP}$。

有 $\mathrm{RL}\sube \mathrm{NL}\sube \mathrm{P}$，同样 $\mathrm{BPL}\sube \mathrm{P}$，且 $\mathrm{BPL}\sube \mathrm{L}^{3/2}$。

<h2 id="交互式证明">交互式证明</h2>

<h3 id="定义">定义</h3>

考虑多次交互来验证一个计算某个语言的函数是否正确。

两个部分，分别是 Prover 和 Verifier，一般认为 Prover 是无限强大的，而对 Verifier 则有一定的限制。交互过程形如每次先将语言的一个实例输入给 Prover 和 Verifier，然后 Verifier 根据这个实例给定 Prover 一个输入，Prover 根据实例和 Verifier 的输入给 Verifier 一个输出，不断重复该过程。

使用形式化语言描述交互过程：对于函数 $f,g:\{0,1\}^*\to\{0,1\}^*$，$k$ 为整数，一个 $f$ 与 $g$ 之间的 $k$ 轮交互，记作 $<f,g>(x)$，指的是如下定义的字符串序列 $a_1,a_2,\dots,a_k\in \{0,1\}^*$：


$$
a_1=f(x),a_2=g(x,a_1),\dots,
a_{2i+1}=f(x,a_1,\dots,a_{2i}),a_{2i+2}=g(x,a_1,\dots,a_{2i+1})

$$

$f$ 最终的输出，记作 $\mathrm{Out}_f<f,g>(x)$，定义为 $f(x,a_1,\dots,a_k)\in \{0,1\}$。

考虑确定性交互证明（Deterministic Interactive Proofs/DIP），称一个语言 $L$ 有 $k$ 轮确定性交互证明系统当存在一个 DTM $V$ 满足对于输入 $x,a_1,\dots,a_i$ 运行时间为 $\mathrm{Poly}(|x|)$ 并且存在一个 $k$ 轮的与任意函数 $P$ 的交互满足：


$$
x\in L\Rightarrow \exists P:\{0,1\}^*\to\{0,1\}^*,\mathrm{Out}_V<V,P>(x)=1\\
x\notin L\Rightarrow \forall P:\{0,1\}^*\to \{0,1\}^*,\mathrm{Out}_V<V,P>(x)=0

$$

上一条被称作完备性（completeness），下一条被称作可靠性（soundness）。

由于都是确定性的，容易看出 $\text{DIP}$ 其实很弱，事实上 $\text{DIP}=\text{NP}$，考虑 $a_1,\dots,a_i$ 刚好对应 $\text{NP}$ 里的证书。

考虑非确定性的 Verifier。称一个语言 $L$ 属于 $\mathrm{IP}[k]$ 当存在多项式时间的 PTM $V$ 有和任意函数 $P:\{0,1\}^*\to \{0,1\}^*$ 有一个 $k$ 轮交互：


$$
x\in L\Rightarrow \exists P:\{0,1\}^*\to\{0,1\}^*,\mathrm{Pr}[\mathrm{Out}_V<V,P>(x)=1]\ge 2/3\\
x\notin L\Rightarrow \forall P:\{0,1\}^*\to \{0,1\}^*,\mathrm{Pr}[\mathrm{Out}_V<V,P>(x)=1]\le 1/3

$$

同样上一条完备性，下一条良好性。

定义 $\mathrm{IP}=\cup_{c\ge 0}\mathrm{IP}(n^c)$。

很显然通过常数次独立询问可以将出错概率减到指数小。

首先有 $\mathrm{IP}\sube\mathrm{PSPACE}$。

考虑 $\mathrm{IP}$ 的定义，Prover 对于 Verifier 来说可以算是一个黑盒，所以事实上我们可以直接枚举 Prover 每次给 Verifier 的返回值，找到其中最优的，于是即可判断，容易发现这可以在 $\mathrm{PSPACE}$ 中完成。

<h4 id="图不同构问题graph-non-isomorphismgni">图不同构问题（Graph Non-Isomorphism/GNI）</h4>

判断两个图 $G_1,G_2$ 是否不同构，该问题属于 $\mathrm{IP}$。

具体而言，将两个图给 Verifier 和 Prover，Verifier 随机选择一个下标 $i\in \{1,2\}$，然后将 $G_i$ 编号随机打乱给 Prover 要他判断这是哪张图，如果二者同构则 Prover 无法判断，失败概率 $1/2$，尝试多次即可将该概率减小到指数小。

<h3 id="-有多强">$\mathrm{IP}$ 有多强</h3>

<h4 id="_-8">$\mathrm{coNP}\sube\mathrm{IP}$</h4>

考虑 $\#\mathrm{SAT}$ 表示有多少种赋值方式可以满足某个 CNF，具体而言 $<\phi,k>$ 属于该语言当 $\phi$ 为 CNF，且恰有 $k$ 种赋值方式可以使得 $\phi$ 为真。

使用计数问题来描述，$x_i$ 取真表示取 $1$，取假表示取 $0$，则 $x_i\land x_j=x_i\cdot x_j,x_i\lor x_j=1-(1-x_i)(1-x_j),\lnot x_i=1-x_i$。由此我们可以把一个 CNF $\phi$ 用一个多元多项式 $P_{\phi}(x_1,x_2,\dots,x_n)$ 来描述，我们的问题变成判断以下等式是否成立：


$$
\sum_{b_1\in \{0,1\}}\sum_{b_2\in \{0,1\}}\cdots \sum_{b_n\in \{0,1\}}P_{\phi}(b_1,b_2,\dots,b_n)=k

$$

注意到某个 $x_i$ 在 $P(x_1,x_2,\dots,x_n)$ 的次数最多为 $n$ 次。

如此递归构造交互式证明系统：首先找一个较大的质数 $p$，让判定该等式膜 $p$ 意义下进行。对于第 $i$ 次判定形式化为判断是否有 $\sum_{b_i\in \{0,1\}}\sum_{b_{i+1}\in \{0,1\}}\cdots \sum_{b_n\in \{0,1\}}P_{\phi}(a_1,\dots,a_{i-1},b_i,\dots,b_n)=v_i$，要求 Prover 给出一个多项式 $s_i(x_i)=\sum_{b_{i+1}\in \{0,1\}}\cdots \sum_{b_n\in \{0,1\}}P_{\phi}(a_1,\dots,a_{i-1},x_i,b_{i+1},\dots,b_n)$，然后看 $s_i(0)+s_i(1)$ 是否等于 $v_i$，如果不相等直接返回 reject，如果相等考虑到 Prover 可能会作弊返回假的 $s_i$，所以我们还需要验证 $s_i$ 的正确性，随机取 $0\le a_i<p$，求出 $v_{i+1}=s_i(a_i)$，然后递归验证。

考虑递归到底层，需要判断是否有 $P_{\phi}(a_1,\dots,a_n)=v_{n+1}$，这个直接计算可得。

注意到如果存在一次 Prover 给出了假的 $s_i$，那么其和真的差次数最多为 $n$，最多有 $n$ 个根，所以在后续验证正确的前提下，这一次找到的 $a_i$ 出现破绽的概率最多为 $1-n/p$。由此 Prover 作弊了 Verifier 找到错误的概率大于等于 $(1-n/p)^n\ge 1-n^2/p$，取 $p$ 足够大即可，而验证 $p$ 是质数可以 Miller-Rabin。

注意到 $\#\mathrm{SAT}$ 显然强于 $\lnot\mathrm{SAT}$，所以有 $\mathrm{coNP}\sube\mathrm{IP}$。

<h4 id="_-9">$\mathrm{PSPACE}=\mathrm{IP}$</h4>

考虑一般化到 TQBF，$\forall$ 对应 $\prod$ 而 $\exists$ 对应 $\sum$，将 TQBF 转化为表达式后问题变为判断是否有：


$$
\prod_{b_1\in \{0,1\}}\sum_{b_2\in \{0,1\}}\prod_{b_3\in \{0,1\}}\cdots \sum_{b_n\in \{0,1\}}P_{\phi}(b_1,b_2,\dots,b_n)\ne 0

$$

问题在于由于使用了 $\prod$ 每个变量的次数可以提升到 $2^n$ 级别，这是不可接受的，注意到当 $x_i\in\{0,1\}$ 时有对于任意非负整数 $t$ 满足 $x_i^t=x_i$，所以次数其实没有多大意义，定义降次操作 $L_i(P(x_1,x_2,\dots,x_n))$ 为：


$$
\begin{aligned}
L_i(P(x_1,x_2,\dots,x_i,\dots,x_n))&=x_iP(x_1,x_2,\dots,1,x_{i+1},\dots,x_n)\\
&+(1-x_i)P(x_1,x_2,\dots,0,x_{i+1},\dots,x_n)
\end{aligned}

$$

等价于将第 $i$ 个变量 $x_i$ 最高次数强行转化为 $1$，问题变为判断是否有：


$$
\prod_{b_1\in \{0,1\}}L_1\sum_{b_2\in \{0,1\}}L_1L_2\prod_{b_3\in \{0,1\}}L_1L_2L_3\cdots \sum_{b_n\in \{0,1\}}L_1L_2\dots L_nP_{\phi}(b_1,b_2,\dots,b_n)\ne 0

$$

同样取大质数 $p$，然后递归地拆每一层往下判断，这样可以保证拆到任意层的需要返回的多项式次数最多是 $2$。

具体而言拆 $\prod$ 返回 $s_i()$ 判断是否有 $s_i(0)s_i(1)=k$，拆 $\sum$ 返回 $s_i()$ 判断是否有 $s_i(0)+s_i(1)=k$，拆 $L_i$ 有点复杂，返回 $s_i()$ 判断是否有 $a_is_i(1)+(1-a_i)s_i(0)=k$（$a_i$ 是之前每一步确定好的值）。

和上面类似，于是我们可以得到 $\mathrm{TQBF}\in\mathrm{IP}$，而 $\mathrm{TQBF}$ 是 $\mathrm{PSPACE}-complete$ 的，而之前我们有过 $\mathrm{IP}\sube\mathrm{PSPACE}$，所以立即有 $\mathrm{IP}=\mathrm{PSPACE}$。

<h4 id="_-10">$\mathrm{MIP}$</h4>

考虑多个无法交流的 Prover 的情形，那么我们的 Verifier 可以让它们之间交叉验证，可以证明多个 Prover 有任意多项式级别个 Prover 等价于只有两个，且我们有 $\mathrm{MIP}=\mathrm{NEXP}$。

<h3 id="_-11">$\mathrm{AM}$</h3>

需要注意我们 $\mathrm{IP}$ 中 Verifier 的随机性 Prover 是无法得知的，而有一个复杂性类类似 $\mathrm{IP}$，不过随机的过程是对 Prover 公开的（Public coin，公开抛硬币），由此定义 $\mathrm{AM}[k]$ 为 $\mathrm{IP}[k]$ 的子集且每次 Verifier 给 Prover 的信息都会包含 Verifier 所用到的所有随机比特。

我们有性质 $\mathrm{AM}[2]=\mathrm{BP\cdot NP}$，且对于任意常量 $k\ge 2$ 有 $\mathrm{AM}[k]=\mathrm{AM}[2]$。

事实上有 $\mathrm{IP}[k]\sube\mathrm{AM}[k+2]$。

<h4 id="_-12">$\mathrm{GNI}\in\mathrm{AM}[2]$</h4>

只有两轮交互，也就是 Verifier 问一次而 Prover 回答一次。

考虑关于 $G_1,G_2$ 的一个集合：


$$
S=\{(H,\pi)|(H\cong G_1\lor H\cong G_2)\land \pi \in \mathrm{Aut}(H)\}

$$

其中 $\mathrm{Aut}(H)$ 表示 $H$ 的自同构函数集合，那么容易发现 $G_1\cong G_2$ 则 $|S|=2n!$，否则 $|S|=n!$。

考虑对于任意集合 $S$，对于某个 $K$，构造一个交互过程使得当 $|S|\ge K$ Verifier 大概率接受而 $|S|\le K/2$ 时 Verifier 有概率拒绝。

具体而言考虑随机哈希函数。

令 $\mathcal{H}_{n,k}$ 为 $\{0,1\}^n\to \{0,1\}^k$ 的函数集合，称 $\mathcal{H}_{n,k}$ 是两两独立的当 $\forall x,x'\in \{0,1\}^n,y,y'\in \{0,1\}^k$，有：


$$
\mathrm{Pr}_{h\in \mathcal{H}_{n,k}}[h(x)=y\land h(x')=y']=2^{-2k}

$$

令 $\mathrm{GF}(2^n)$ 表示一个包含至少 $2^n$ 个元素的有限域，如此构造 $\mathcal{H}_{n,n}=\{h_{a,b}\}_{a,b\in \mathrm{GF}(2^n)}$，其中 $h_{a,b}$ 为 $\mathrm{GF}(2^n)\to \mathrm{GF}(2^n)$ 上的函数满足 $h_{a,b}(x)=ax+b$，根据域中每个非零元素可逆知其为两两独立的。

$\mathcal{H}_{n,k}$ 直接截断 $\mathcal{H}_{n,n}$ 的输出为 $k$ 个比特即可。

对于任意可以验证的语言 $S\sube \{0,1\}^m$（有一个证书可以判定每个字符串是否属于 $S$），双方知道一个数字 $K$ 满足 $2^{k-2}<K\le 2^{k-1}$。

Verifier 每次随机选择 $\mathcal{H}_{m,k}$ 中的一个元素 $h$，随机取 $y\in \{0,1\}^k$，然后将 $h,y$ 发给 Prover。

Prover 目的是尝试寻找一个 $x\in S$ 满足 $h(x)=y$，然后将 $x$ 以及其证书发给 Verifier 以供验证。如果 Prover 成功这么做了 Verifier 就同意否则拒绝。

考虑这么交互下 Prover 能够正确返回的概率。不妨令 $|S|\le 2^{k-1}$，那么对于 $p=|S|/2^k$，有：


$$
\frac{3p}{4}\le \mathrm{Pr}_{h\in\mathcal{H}_{m,k},y\in\{0,1\}^k}[\exists x\in S,h(x)=y]\le p

$$

上界根据 $|h(S)|\le |S|$ 立即得到。

下界事实上有对任意的 $y$，$\mathrm{Pr}_{h\in\mathcal{H}_{m,k}}[\exists x\in S,h(x)=y]\ge \frac{3p}{4}$。令 $E_x$ 表示事件 $h(x)=y$，那么有


$$
\begin{align}
    \mathrm{Pr}_{h\in\mathcal{H}_{m,k}}[\exists x\in S,h(x)=y]&=\mathrm{Pr}_{h\in\mathcal{H}_{m,k}}[\lor_{x\in S}E_x]\\
    &\ge \sum_{x\in S}\mathrm{Pr}[E_x]-\frac{1}{2}\sum_{x\in S}\sum_{x'\in S,x'\ne x}\mathrm{Pr}[E_x\cap E_{x'}]\\
    &\ge |S|2^{-k}-\frac{|S|(|S|-1)}{2}2^{-2k}\\
    &=p(1-\frac{|S|-1}{2^{k+1}})\\
    &\ge \frac{3p}{4}
\end{align}

$$

由此我们考虑验证上面关于 $G_1,G_2$ 给出的集合 $S$ 是等于 $2n!$ 还是 $n!$，令 $K=2n!,K\in (2^{k-2},2^{k-1}]$，那么这样进行一次验证，当 $G_1\ncong G_2$ 时接受概率 $\ge \frac{3}{4}\frac{K}{2^k}$，而当 $G_1\cong G_2$ 时接受概率 $\le 0.5\frac{K}{2^k}$。多路并行询问一次，然后使用投票可以使得成功概率较大。

