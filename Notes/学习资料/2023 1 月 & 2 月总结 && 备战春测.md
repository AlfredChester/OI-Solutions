# 2023 1 月 & 2 月总结 && 备战春测

### 1.11

咕咕咕咕呱。

### 1.12

今天干了啥：

-   听课然后发表 sb 言论
-   点分树有点点细节不确定，回看 辰星凌-点分治
-   听点分治的时候想起了 20221031T4 的高级 点-边容斥 + 神奇点分治计算贡献方式，回看
-   想起了 CSP2022T4 的神奇把询问用点分治拆开，达到 log^2 -> log（化曲为直） 的 trick， 回看
-   想起了CF603E Pastoral Oddities 的从后往前的线段树分治+高级结论+优秀的分析方式，回看
-   思考扩展域并查集判断二分图，发现实际上可以将二分图理解成左右两边为敌人，连边即为确认敌人关系
-   思考 Painting Edges，感觉 LCT 可以乱杀，回看 Loj 动态图联通性
-   想并写出 Painting Edges ，感觉实际上最多紫题
-   想并写出 开店，对点分树有了更深的理解
-   回看 WC2011 最大路径异或和，想并写出 Shortest Path Queries。感觉想题的时候不是特别集中，中间想不动了在梦游。自己想了一个 log^3 的蠢算法，蠢在两棵树合并的时候采用的是启发式合并，但是实际上不需要，只要充分利用异或的性质，可以轻松砍掉这个 log
-   秒了\[CF601E\]A Museum Robbery 但是懒得写了

综上看来，今天状态还行，爽

### 1.13

今天干了啥：

-   思考林克卡特树，得到一个错误做法。看题解发现是 DP 想错了，原因是以为最后得到的链形如0/1条曲链+一些边权都为正的链。但是实际上是错误的，“一些链”也可以包含负边，也可以是曲的。也就是把问题分析得不够清晰，应该分析为：删掉K条边后，得到k+1条联通块。这样思考容易避免上述问题。然后自己重新设了一个状态，写了 1h 左右只能过样例。看题解，发现这道题 DP 初值很讲究。
-   写 \[CF150E\]Freezing with Style ，调了一段时间
-   在 zqm 的提示下得到了\[CF364E\] Empty Rectangles 的正解，细节有点多，没写完

综上来看，代码能力有待提升

### 1.14

今天干了啥：

-   带大家分析了一下 \[JOISC2017 Day4\]誘拐 2/Abduction 2
-   终于调出来了 \[CF364E\] Empty Rectangles，总用时 4h，开心。然后去学习了一下题解的简洁实现方法
-   写掉 \[CF601E\]A Museum Robbery
-   思考 NIKKEI Programming Contest 2019 F。会了一个 n^2logn 的决策单调性背包。看题解，发现忽略掉的一个重要性质是所有物品的重量都为 1；此时，如果没有同一个颜色必须出现两次的限制，很显然直接从大往小选。有这个限制，考虑将每一个颜色前两大打包一起选，给每种颜色整个 ptr 表示当前选到哪里了。选择方案一定是选了一些 被打包起来的 2 和一些散装的。求解背包容量 i->i+1 的答案时，可以是 直接选择一个散装的/撤销一个散装，加入一个打包/撤销一个打包，加入某颜色前三大（考虑前两大可能此颜色不优，但是考虑前三大可能优）。需要使用单调队列，nlogn。
-   这道题的思考和实现都很**妙**啊，这种看似背包的问题一定要注意可能可以利用性质直接做。类似的是才讲的 「CF1442D」 Sum，也是利用性质，不要一来就背包。

综上来看，可以。

### 1.15

今天干了啥：

-   终于找到了为什么前些天的上午会犯困：有两种要吃的药，一种白天吃，一种睡觉前吃，吃反了。然后昨天忘记吃了，所以什么事都没有。可惜今天也吃错了/qd
-   今天没有打乒乓，午觉是在 12:20-12:40，作息乱掉了睡得不是很好。下午上课状态不太行。
-   下课把列表大部分题都想了一遍，想出少部分正解，大部分都很接近正解，毕竟 DS。然后补觉。
-   复习列表原题：Segment 和 \[CF453E\]Little Pony and Lord Tire
-   写 \[POI2015\]Logistyka 和 \[SHOI2015\]脑洞治疗仪
-   正确并较快口胡了 ABC285ABCDEFG。E 最开始读错题了，影响了后续的思考/ll

### 1.16

啥干了今天：

-   CF280D k-Maximum Subsequence Sum，虽然没有想出这道题的解法，但是想并写出了他的弱化版 P6821 \[PA2012\]Tanie linie（直接贪心）。感觉这种 反悔贪心->费用流->模拟费用流的题见过很多次了，但是每次都没有反悔贪心的意识，想的是线段树上每一个点挂个 DP 数组。这样做是可以做，但是复杂度 G 了。
-   \[六省联考 2017\] 相逢是问候。挺神的一道题，其实看样例应该会发现思路，毕竟第二个样例后面全都是一样的输出。一般这种区间覆盖的问题，往往都是 颜色段均摊/只会修改 log 次
-   ABC285Ex 场上思考到了容斥，但是没有想到使用生成函数进行计算，一直 DP 不动。遇到 只能选偶数 这种限制，应当思考生成函数方向
-   \[AGC031E\] Snuke the Phantom Thief。正确地往费用流方向思考，因为有很明显的分配关系。但是直接建图是不行的，一个想法是把同种限制建在一条链上，这样，我选择这个链上的一个点，会将前缀流量消耗，满足了一方面的限制。但是因为需要满足四方面的限制，做不到同时让四条链的一个前缀减少。一个神奇的转化是辩证地看待这些限制，前 x 的范围内最多放 y 个物品，目光着眼整体，条件等价于第 y + 1 的物品至少放在 x + 1 处。得到了 \[L,R\] 表示对于一个物品放置位置的限制之后，是一个简单的费用流。可能的问题是要保证必须挨个在 \[L,R\] 区间里面放数字，即满足 Li,Ri 的限制一定是针对 排序后第 i 个放下的，由于 L, R 分别递增，所以实际上不会出现跳过区间的情况，可以想见，跳过的情况只出现在 n 个物品往 m 个位置 n>m 时，但是此时必然出现限制区间的重合，由于递增，等价认为是放在前一个区间。
-   \[Code+#1\]Yazid 的新生舞会：看懂了 nlogn 的 BIT 维护三位前缀和、nlog^2n 分治、O(n) 的方法，没时间写。

综上来看，还行，感觉效率可以更高

### 1.27 模拟赛

感觉打得不是很顺，可能是一段时间没碰了。

T1 费用流->反悔贪心->DP->直接贪心->得到正解。文件名写错了，而且好像我用 vector 写高精会 T，不知道哪里写错了

T2 由第二档部分的 > m/2 想到切两半，然后想了一会儿得到了一个近似正解，但是最后双指针部分想得不是很周到，70pts,GG.

T3 迅速得到简单分块 n\\sqrt n 小常熟做法，但是斜挂一个小细节：**lower/upper\_bound 找左右边界的时候，由于是 pii，应该分别赋 pii(x, 0) 和 pii(x, inf)。**

T4 看了一眼，很有根号分治的感觉，部分分很充实，但是没有时间打了。

下午调了很久 T23，晚上写+调 2h T4。

码力不够，有待提升。

思考并学习了 #6637 可重集计数，很神。

### 1.28 pb 博弈论+推性质

有被震撼到，晚上感觉脑子不够用了，很多没有消化

-   自行推出：CC DESTRUCT
-   思考并看懂：SRM789 Hard ；CF1442F Differentiating Games ；XXI Open Cup GP of Korea – L； XXI Open Cup GP of Krakow – H ； ARC125F Tree Degree Subset Sum ----------- 并写出：CF1477D Nezzar and Hidden Permutations；CTS2022 D1T2
-   还在想：AGC040F Two Pieces
-   口胡 ABC287，被 Ex 骗了，以为是最小树形图之类，很麻烦，但是实际上可以暴力传递闭包+bitset优化

需要归纳！

### 1.29 消化 pb

-   AGC040F Two Pieces 看懂，自己推了推折线法，帮助 czl 探究此题的 GF 做法，虽然帮助不大，但是学到了一点 GF 和推式子
-   简单体悟了一下这两天的题，感觉之前给每一道题简单的自己写一个题解是有必要的，可以增进体会
-   终于解决了 虎年Final T2 可重集计数，很妙的一道题，涉及到“搭楼梯”DP 的技巧 和 容斥技巧
-   把 CF1442F Differentiating Games 写掉，这道题主要是注意到 20 这个数据的特殊性 + 完全 DAG 使得 SG 值不同以区分不同的数，很妙。
-   给 zqm 讲了 CTS2022D1T2，自己有了新的收获
-   口胡 ARC155 ABCD，不知道对不对

### 1.30 fsy

-   看了 ARC155 ABCD 的题解，A 结论算是糊对了，B 的做法有正确性但是非常丑陋，C 漏了一点细节讨论；D 题我实际上没有得到实际做法，只是算了算感觉暴力 SG 复杂度挺对的，题解说明了复杂度确实是对的，花了点时间和 zqm 讨论懂了题解对于复杂度的证明，然后学习了一下优雅的代码实现
-   Gym102770L List of Products：实际上可以把每一个数字唯一分解之后理解成一个大进制数，那么原数的相乘对应进制数对应位相加，大小比较和字符串的比较是一样的。那么这样就容易发现性质：若 a "<" b, c "<" d，那么 ac "<" bd，对应到大进制数上就是 a + c < b + d
-   Gym 102769I Interstellar Hunter 基向量思想
-   Gym102769L Lost Temple 借出题人的说法，是一道需要想象力的题。可以发现一个点被干掉的时间等价于最短路，那么发现相邻两列答案相差不超过 1。那么现在只需要判定一个列是否可以取到某个答案。分析一下发现可以用单调栈判。
-   Gym102769H Holy Sequence 考 虑 D P 组 合 意 义 + 性质观察以优化。
-   Gym102759E Chemistry 扫描线题，想到了性质，没有想到扫描线，一个警告！
-   做了点套路的总结

### 1.31 模拟赛

-   8：00 思考 T1 分治+01trie 做法
-   8：30 写 T1 数位 DP 做法
-   9：30 调出 T1 运算符优先级问题
-   9：40 发现大样例不过是因为行末空格
-   10：00 不会 T2
-   10：10 给 T1 加 fwrite 保险
-   10：30 T4 ？？？
-   11：30 放弃 T4

T1 差不多一共花了 2h30min，分治做法的思考起点是容斥，容斥需要计算类似左区间对右区间的贡献，那么不妨直接考虑分治。但是分治是做不了的。

很数位 DP，30min 写完第一版，1h 调了一个 **(!(x >> i) & 1) 的问题，此时 ! 是先于 & 进行计算的，会 GG**

**cmd 的 fc 居然不能过滤行末空格**，差评

T1 直接容斥会更好做

T2 转化成了：给每一个格子颜色 0/1/2，要求所有颜色 1/2 可以分别被两个合法矩形包裹。然后顺理成章的写出来一个会严重算重的 DP，因为 1/2 其实是不应该区分的，而且这个算重是难以处理的，因为不知道到底区分了多少个数字

然后稍微画了画，发现

-   上、下、左、右都肯定有反面朝上的棋子（否则就不是最小的矩形）
-   要么反面朝上的棋子全在左上 X × Y 和右下 X × Y 的矩形内，要么全在左下 X × Y 和右上 X × Y 的矩形内。

然后不知道怎么办了/qd，实际上可以直接根据这个组合数容斥计算。

学到了一点容斥的方法。

T3 因为时间不多，看到字符串然后被吓跑了，没想到直接并查集居然 58pts，亏死

实际上，是一道有趣的 推性质+DS（启发式合并）题目。

T4，需要一点脑洞的贪心题目，只维护最极端情况下的路径。

---

感觉今天下午脑子就开始有点晕，不够用了，晚上状态良好。上午 T1 花费的时间有点久，T3 怕字符串是不应该的。

T4 的这种格式很像一道线段树分治的题目，做了一个区分。

然后开冲 CF Chemisty，准备自己口胡一个 LCT 出来，没写完。

### 2.1 模拟赛

2h T4，心态有点小炸，虽然一开始想的就是正确的思路，但是在写代码的过程中为了写代码的方便，捏出了一些错误的性质，以为 +-+ 这种在某些条件下是可以贪心合并的，写了很久最后全部删掉重来了；没有过题，原因是给不合法的状态设成了 -1e18，然后做了乘法，直接爆掉。

思考 1h30min 左右的 T1。因为这道题的主要矛盾在于算重问题，这种题感觉有点像 \[20220718海亮NOI集训\]数数，即不断转化枚举量，然后结合组合意义等进行计算。可惜，转化了很久没有得到一个比较好算的条件。然后糊了一个 n^3 的 sb DP。

简单看了 T23 题面发现 T3 不是很可做，剩下 1h 全部 rush T2

T2 一看就是需要一些转化贡献计算技巧的题目，这种转化贡献计算方式的题目感觉见过不少了，比如 [https://www.luogu.com.cn/problem/CF891E](https://www.luogu.com.cn/problem/CF891E) 。但是不太会转化，思考到一种“搭楼梯”式 DP，即直接枚举怒气值 i 的贡献出现了 j 次，做一个类似背包的 DP。但是这样复杂度太大了。

---

T1 正解是聪明的性质分析+巧妙重复状态利用

T2 正解的确是转化贡献的计算方式，或者叫做构造一个双射，使得原来的贡献等价于新问题的代价和。

T3 看了较久的时间，留下了一点细节没有看懂。

---

下午心态出现了一点焦虑，是太急躁了，感觉自己脑子太笨。

其实不需要这么着急的，慢慢来就好。

### 2.2 数学杂题选讲

今天的题都挺好的，找时间写总结。

### 2.3 模拟赛

> 7：45 发现把 T4 的 m 理解成了 max(n, 5)，发现是 sb 题
> 
> 8：30 DP 写不对，自闭
> 
> 8：45 自信退出 T4
> 
> 10：30 写完 T1 80pts
> 
> 11：00 无事给 T1 写对拍，但是暴力写错了（把暴力的空间大小开错了），调了一会儿，吓死了/qd
> 
> 11：10 开始神志不清
> 
> 11：30 结束 T1
> 
> 11：44 T2 暴力

T4 没开 long long 挂了 20pts，T1 判树的情况没判好，挂了 20pts

对自己的速度不太满意，T4 1h15min 算是比较可以接受，但是 T1 由于过于执着于纯数学式子的推导容斥，而没有直接简洁明了地画出不合法的情况，导致计算方式很复杂，而且需要步步小心转化式子没有错误。

好的方面是，把原本复杂的式子一步步推出来，加上一个不断修正的过程，是好的。

---

T1 新 trick，m\\sqrt m 枚举三元环。

T2 考察性质分析，考场上思考的时候，想到了“如果 lca 换到某一个点，那么需要保证子树外的点全部处理完毕”，实质上已经得到了关键性质。后续是一个 DP 的问题。学习到了一个“经典”的 DP。

T3 很神，听完题解之后感到得到了升华，感觉 sqy 对于算法的理解是非常深刻的。看到恰好 k 个可以想到 wqs 二分，思考一下确实可以。设 f\[i\] 表示 i 为最后一段末尾最小值，发现转移具有决策单调性。对于这种特殊的，贡献计算适用莫队类方法，状态之间没有分层的 决策单调性 DP，可以使用 CDQ 达到手动分层的目的，此时复杂度 nlog^3n。

一个 log^3 -> log^2 的方法是，建立出广义笛卡尔树之后，分析性质可以得到 O(1) 计算任意一个 f(l, r) 的方法，那么可以直接用单调栈做决策单调性。

正解是，抛弃上述为了决策单调性衍生的做法，考虑广义笛卡尔树的结构，容易发现可以做一个树形 DP，这个树形 DP 可以通过斜率优化做到 O(n)，总复杂度 $O(n\log n)$

### 2.4 sqy 构造

上午比较困，状态不太好；下午先去搞了搞昨天 T3，遇到了问题，和 zqm 没讨论出来，sqy 忘记当时的推导了，G；之后都在搞今天的题，今天题挺有意思的，sqy 讲得很详细。

今天的题代码没咋写。

-   琪露诺的符卡交换1：一个看起来很对的方法是分开处理每一个颜色，然后把差的和多的凑一凑，肯定是有解的，但是这样的问题是一次交换涉及到两个颜色，这里面显然涉及到一个分配的问题。一个人看成一行，每一行数字的顺序显然是不重要的，分析 subtask 可以发现，如果可以通过排列每一行，使得每一列的数互不相同，对当前矩阵做一个转置可以得到解。可以做成一个二分图匹配问题，行一排点，颜色一排点，需要划分成 N 个完美匹配，由 hall 定理，发现一定可以。
-   Triangles：假如构造了 f(k)，随便找一个中点三角形，可以构造出 f(k + 3)。需要分析到的性质是，处于矩形中间的点度数为 4/5，为 4 当且仅当在某一个三角形的边上。一通分析+暴力手画，可以构造出 n = 8,9,10 的解并证明没有更小的情况。
-   Wersja dla profesjonalistów：性质：大小为 N 的三角形图可以看成两个相同的大小为 n/2 的三角形图+菱形。注意到菱形的构造是代价很小的。
-   Icy Itinerary：诈骗题，考虑逐步插入每一个点进入序列，依据和分界点 p 的关系即可。或者叫做调整法
-   Stacking Up：诈骗题，倒序构造每一个一个数，这是容易 logn 做到的，构造了后面的数，假如使用了 dlt 次 +，那么当前需要构造的数变成 a + dlt
-   Squid Game：排序后，如果 a0 = 1，那么利用二进制拆分，可以把 a1 变成 0。否则，注意到如果 a1 % a0 == 0，也是没有问题的。否则，先按照原来的做，会导致剩下一点，重新排序继续做，可以证明次数不太多。
-   Build the String：一个连续段一个连续段地构造，并不难。
-   Graph Coloring：注意到 C(14, 7) > 3000，那么可以给每一个点的出边分配不同的颜色集合即可。
-   Not Same：容易构造的。

### 2.5 模拟赛

感觉今天也是没带脑子的一天。

> 7：40 打开题目
> 
> 7：45 发现 T4 是原题
> 
> 8：20 解决 T4，尴尬，差点想错了
> 
> 8：40 惊觉 T1 可以直接暴力数位 DP，不需要考虑 mitm/分治/ppc性质 之类
> 
> 9：20 更换 DP 状态
> 
> 9：40 再换 DP 状态
> 
> 10：00 分析发现 T1 直接 DP 实在是难蚌的，考虑容斥
> 
> 11：00 T1 自闭
> 
> 11：20 会 T2 N^4log 费用流做法
> 
> 11：30 彻底放弃 T1
> 
> 11：50 摆烂

T4 写错一个小细节，还是挂了。T1 我的容斥+数位 DP 终究还是错付了，一个听起来就不太对的算法，其实在 9：20 第一次准备换状态的时候，就想到了直接把分界点 S 用一个二进制数记录下来，但是没敢仔细算复杂度，直接抛了。

只能说是有点懦弱，分析心里应该是害怕算出来是不想要的结果，然后直接不敢算了。

T2 的费用流做法是，显然可以类比 小 M 的农场，对于 k 的限制，可以采取 wqs 二分的方法解决

---

T1，直接塞进去发现可以过 80pts，分析一下感觉合法状态数很少。此时有两种处理方式，一种是预先把所有合法的转移方式预处理出来；一种是观察到某一个位置合法仅仅和 s 与上一个位置的 0/1 有关，那么可以类似轮廓线 DP。

学习了一下 T1 的纯容斥方法，感觉实际上是比较自然的方法。但是讲得很不清楚/fn

T2 需要一个巧妙的转化，将复杂的贡献计算方式转化为常数之后，贪心解决

T3 巧妙构造，感觉比较 ad-hoc，积累。

---

晚上比较摆烂，每天都在用脑子，但是回家不肯早睡觉，就在那里玩手机，属于是脑子有问题。

### 2.6 DS

上午听了 DS，听的时候脑子不是很灵光，讲完之后觉得思维难度低。

下午写掉了昨天模拟赛的 T2，给 T1 的容斥方法写了一个题解，写了今天的 T1。

放假 ohhhhhhhhhhhh

-   CF1672H Zigu Zagu：考虑称 11 为黑点，00 为白点，设黑点 x 个，白点 y 个。一次操作要么是 x, y 同时-1，要么 x/y 减少 1，所以答案是 max(x, y) + 1

---

2.7 晚上：按照自己的想法，没看题解写 CF1423G Growing flowers

但是居然想了半天不会这个问题：

-   加入一个二元组 $(b, r)$
-   给定一个 $x$，询问 $\sum_{x \le r_i} \max(0, x + b_i)$

$x, b, r \le 10 ^5$

感觉自己蠢到家了

### 2.7 模拟赛

时间分配：

1h T4, 3h10min T1, 5min T2，5min T3，10min 摆烂

成果：T4100 + T1 的错误 sb 贪心 + T2 m = 1 + T3 n^3 DP

虽然 T23 都没有打出来就是（

---

T4 的思考过程是可以的。首先可以搞出 AC 自动机然后转化成图上 DP，看到数据范围想要矩阵加速，分析一下题目性质：“不包含”，可以知道图上每条边边权为 0/1。

这个复杂度还不够，发现图上有很多边权 0 的边其实可以缩起来，思考一下，发现缩完之后，在图上跑路径等价于每次选择两个字符串，例如 abc bcd，跑到 abc，跳到 bc，跑到 bcd，跳到...

此时就直接可以设 $f[i][j]$ 表示已经走了 i 个字符串，当前在 j，使用 kmp 预处理转移矩阵即可。

---

T1 的思考过程是有趣的，读题之后首先转化成一个形式化题意，此时的条件是每一个颜色内部保证呈现两条不相交不降曲线的形式。看到”形成匹配“二字，那么容易得到一个费用流模型，复杂度是 n^4。既然可以费用流，那么就可以反悔贪心。

乍一看这个反悔贪心不太好做。第一眼的感觉应该是如果能找到相同颜色的就匹配，找不到的话，随便找一个，到时候需要换的时候再换，换不了就算了。

md，上述做法实际上是正确的豪神做法，只是当时感觉这个做法的实现比较难搞以及感觉有点太简单了，没有细算复杂度和仔思考正确性，直接抛了。 hs 对于这个做法的证明是可借鉴的：**暴力模拟费用流**，列出所有 10 种可能的增广的情况，然后通过利用 di 递增和 费用为 -1, 0, 1 的性质，使得只剩下 3 种情况，然后发现就对应上述三种调整。

此时大概思考了 20min 左右，我只能说非常可惜！

然后开始思考这个反悔贪心的可做性在于哪里，如果我把边权不搞成 \[ci != cj\] 的形式，搞成特定的权值，还能不能做

显然这样一搞就是不能做的，所以最后的做法一定是利用了这个性质，并且如果将正解套用在 权值任意给定 的情况下，正解没有正确性，那么说明找到的是正解。

这其实是一个很好的判断正解正确性的一个方面，也是一个很好的找正解的思路，即在多个方面去刻画正解。

然后的考虑是假设已经匹配好了 a1...i - 1 和 c1...i-1，考虑类似调整法地新增一对 ai, ci，然后进行一个错误的贪心。

---

T2 经典基环内向树的分析

T3 新技巧 **线头DP**

二者都看懂了，晚上写了一晚上的 T2 写不出来，算上昨天晚上在写的 CF1423G Growing flowers，已经有两道题处于代码没调完的烂尾状态/kk

---

下午心态出现了一点问题，调整过来了，学 OI 还是不能太功利。

### 2.9 DP

上午听了前 6 道就走了，感觉讲得很不清楚！

然后继续调昨天晚上在写的 T2，算上昨天晚上总共用时 4h，做出来了/hanx

下午和 zqm 讨论证伪并修正 [https://www.luogu.com.cn/blog/lzqy/solution-cf1648d](https://www.luogu.com.cn/blog/lzqy/solution-cf1648d) 这一篇题解，很有趣。

感觉今天将就，但是略有一点划水

-   \[AGC002F\]Leftmost Ball：感觉挺好分析的，发现与直接放n种颜色的球不同之处在于白球会算重之类，发现放了一个白球之后，原颜色 k - 1 个就可以随便放，那么 fij 放了 i 个白球放完 j 种颜色，随便 DP。这种“放了一个之后，同种类型的可以随便放”的还有 gym 102769 H Holy Sequence。
-   CF1648D Serious Business：DS 优化 DP，很有趣的“扭曲的线段树”。
-   CF1775F Laboratory on Pluto 数学简单分析+尺取法（双指针）+“搭楼梯”模型
-   CF1430G Yet Another DAG Problem 首先把边的贡献拆到点上，然后进行费用流建模
-   CF1615F LEGOndary Grandmaster：trick 三连击！观察操作，性质是操作前后异或和不变，可以想到如果对 1,0 进行操作，那么异或和也不变。考虑令 $ai = ai \oplus (i\&1)$，此时每次操作就是交换。考虑如果 a, b 中均没有 ?，计算操作步数，设 pi 表示 a 前缀 1 的个数，qi 表示 b 前缀 1 的个数，那么操作步数是 $\sum|p_i - q_i|$。设 $pre[i][j]$ 表示决策结束前 i 个数字，此时 $p_i - q_i = j$ 的方案数，对应处理 suf 即可计算贡献。

### 2.10 模拟赛

时间分配：2h T4, 2h30min T1

T4 想了 30min 左右的二项式反演/值域DP/容斥之类的做法，实在没有办法了考虑直接 DP，发现有 50pts。然后发现 DP 的形式非常子集卷积，然后考虑了很久的 FWT。在思考 FWT 的过程当中，发现其实有很多状态都是空的，于是终于注意到了 $\sum a_i\le 10^7$ 的限制，分析了一下复杂度，发现把 a 排序一下再 DP 就结束了。

T1 看到“恰好”立马二项式反演，但是我什么都做不到。然后思考 2n 的含义是什么，感觉可以分成 1-n, n + 1-2n 两个序列来考虑会更方便，钦定最大值是那一对之后，我非常仔细地推了式子，感觉很对，但是 n = 4 就开始错了。发现实际上不能分成两个序列来讨论，它分开之后并没有我最初所以为的性质，GG。式子其实都推对了，只要把所枚举的范围改改......

---

T2，学习了一下皮克定理的证明，感觉整体还是一道非常巧妙的计数。首先证明 圆心可以看见 和 圆可以看见 是等价的，这个考虑 遮住圆心的圆 对称过去，会遮住圆的另一半。然后希求不会有圆遮住圆心，借助皮克定理，求出最小的 d，表示这个圆的 r 一旦 > d，那么会挡住所枚举的圆心。然后简单莫反。

T3，有趣的构造题。考虑以分治的方式求出排名表，可以得到两个性质 p\[i\] = q\[rev\[i\]\], $\forall j \& i == j, q_j < q_i$，然后可以使用贪心得到一组 q。

---

晚上补了 线头 DP vim，补充了一点之前的总结，简单整理一点 trick，写 CF1615F LEGOndary Grandmaster

### 2.11 zz图论

上午听了前 6 道跑路了，感觉听课的时候脑子不太灵光。

再战 [括号](https://www.fzoi.top/problem/6895)，发现前几天看的时候一直没有理解的点，是因为抄式子的时候抄反了正负号，瞬间获得了一种大仇得报的快感、、、一通乱写顺利通过

下午把前七道的思路搞明白了。

晚上按照自己的理解写 CF1423C Dušan's Railway，但是忽略了一个重要细节于是 GG，调了 1h+

-   CF429E Points and Segments：把 li 视作左括号， ri 视作右括号，现在数轴上每一个位置都可能有一个或多个括号。对这些括号排序，位置相同的左括号排在前面；每两个括号看成一组，想要使得每组括号对外部的贡献为 0。那么，如果组内是同种括号，那么让对应原线段颜色不同；组内括号不同种，让原线段颜色相同即可。设线段\[li,ri\] 的颜色是 ci，上述操作实际上给定了 n 个限制 ci\\oplus cj = 0/1，容易发现一定有解，dfs 构造方案。
-   XVIIopencupGPofChina B：巧妙的分析和问题转化。首先可以证明“钦定1是白色，枚举选定的边子集，要求如果两个点之间有边那么两个点颜色相同，求合法黑白染色方案数”这个问题**在 mod 2 意义下** 和原问题方案数一样：可以发现，如果存在 c 个连通块，染色方案书是 $2^{c - 1}$，所以只在 c = 1 时有贡献。那么，考虑求解当前这个问题的答案，考虑枚举染色方案，发现对于一个染色方案而言，如若存在一条边两个点的颜色相同，那么这条边可选可不选，所以一旦染色出现这种情况，F\_2 下没有贡献。所以唯一有贡献的情况当且仅当是一张 联通二分图。
-   中国邮递员问题：费用流建模。
-   CF1423C Dušan's Railway：假设有 k=2 的数据，则点分治每次把分治重心和子树内其他点连边，这样只用两步。类似的当 k>=3时，每次树分块然后连边，每个非关键点会向上连一条到第一个关键祖先，$\sqrt n$ 个关键点会向上连 $sqrt$ 个非关键点，所以一次的边数为O(n)，总分治次数为 nloglogn； 我理解错误的细节在于认为关键点不需要和上面的非关键点连边，实际上，如若不连，容易构造出不合法。一种聪明的树分块的实现是 dfs 过程中，如果 siz\[u\]>=lim，那么钦定 u 是关键点 并 siz\[u\] = 0
-   Gym104128J Perfect Matching：转化为有两个数组 ai, bi，两个点有连边当且仅当 ai == aj || bi == bj。考虑建立一个二分图，把原本第 i 个点看作左部编号为 ai 的点向右部编号为 bi 的点连边，那么两个原图的点能匹配，当且仅当它们在二分图对应的边有公共顶点。容易证明，如果边数为偶，那么一定存在完美匹配
-   PTZ summer 2020 Day6 J Setting Maps：高超的网络流建模。首先对于 k=1 的情况，可以每个点拆点，入点向出点连 c ，原图中的边连 +inf，实际上是求最小割。对于 k>1 的情况，考虑建 k 层图，每层点之间和上面一样，每层点向下一层对应的出点连 +inf，表示这个点被割掉了，不得不到下一层。s 向 (0,S) 连边，(x,E) 向 t 连边。可以发现如果一条路径有少于 k个选择的点，那么这条路径一定对应 s 到 t 的流量。所以我们一直割，直到二者不连通。

### 2.12 模拟赛

大致回忆一下今天的时间节点：

-   8：35 得到 T4 n^2 但是爆空间做法
-   9：10 从序列的情况入手，发现剩下空间的关键在于改变转移方式，稍微画了一下得到正解并写完
-   9：30 感觉脑子有点晕
-   9：40 想出 T1 O(2^kne) 做法
-   10:10 写完 T1 暴力
-   10:30 对 T1 进行一个小优化并仔细分析了复杂度
-   11:00 放弃 T1
-   11:30 打完 T2 DSU on Tree 做法
-   12:00 得到 T2 nlog^3 做法，看了一眼 T3，决定 rush T2
-   12:50 rush T2 结束

总体来说，时间分配是比较恰当的，T2 最后 rush 出来的算法有正确性但是由于 log^3 + 比较大的常数，确实没有办法通过 t5e4 的点，比较可惜。

---

相对失败的是 T1，暴力的代码实现非常丑陋。

同时，标答中使用了 dijkstra 维护 DP 的方法，对我造成了震撼。自从 9：40 开始，就一直被如何计算最短路困扰。

巧妙的是，发现我实际上需要的是 $f[s][i]$ 表示走到 i ，干掉 s 所花费的最小时间。（$f[s][i]$ 最初的值表示的是刚刚到达点 i）。而观察我所作的转移，发现其实就是做做最短路的过程，所以直接 dijkstra。

其思想可以理解为把 DP 的转移不断细分，从而精简了转移。

这种 dijkstra 维护 DP，很像昨天 PTZ summer 2020 Day6 J Setting Maps 的网络流维护 DP。

---

T2 距离正解只有一步之遥，在于用 DSU on Tree 做这样一个二维数点的东西是丑陋而愚蠢的，需要 log^2，无论是对比线段树合并的 log 还是直接上扫描线的 log，都很丑陋！

当时在做的时候有过写线段树合并的意识，但是由于在学习 dsu on tree 的时候只见过 DSU on tree 复杂度与线段树分治同级，而且对比之下常熟更小、代码更好写的情况，导致下意识认为写 dsu on tree 更好；草稿纸上在列 dp 方程的时候在仅在心中列出了转移条件+对二维数点不敏感，导致虽然隐隐约约感到这样一个东西需要 Log^2 来做有点不对劲，但是没有想到一般的二维数点做法，或者说没有把这个问题看成是一个二维数点的问题。

当时还思考了换根 DP 的做法，失败了。wfls 的老哥给出了一个具有启发性的思路。首先可以拿 ~~DSU on Tree~~/线段树合并/扫面线 求出 f\[u\] 表示往子树内走的答案，如若想要求出 g\[fath\] 表示 fath 走 u 子树以外的答案是困难的。关注到换根 DP 的特点是仅有从根节点到 u 这条链上的点的贡献不是 f，把贡献拆成两部分：在到根路径上的/其他的

第一个部分可以使用可撤销树状数组解决，第二个部分考虑类似点分治合并子树的手法，考虑搞一个 DS，每次 dfs 从某个点推出的时候就把这个点的信息加入这个 ds，那么实际上，当我求解到 v，ds 中就保存了所有的 dfn 序 < dfn\[u\]，且非到根路径上的点的信息，正反做一遍即可。

---

T3 比较高级，晚上思考了大概 1h30min，总算是看懂了代码（虽然思考是比较间断的），爽死了。

### 2.13 模拟赛

-   9:00 结束 T4
-   9:50 发现 T1 分析反了一个细节，md
-   10:30 发现 T1 可能是 sb 题！
-   11:10 cnm，T1 不会了，放弃 T1
-   12:20 T2 小自闭
-   12:40 感觉会了 T2 正解，rush!

今天考试的时候是有点自闭的，因为感觉 T1 很可做但是不会做，T2 分析到最后其实是有点绝望的，因为可能在 11:40 左右得到了一个做法，但是上手写的时候全是问题，根本写不下去。

---

T1，首先我会 n<=16 + k = 0 + k = 1。

令 (1) 表示一个递增段，(-1) 表示一个下降段，最开始分析错了，认为：

-   如果操作一个 (1)，那么会变成 (1)(-1)(1)
-   如果操作一个 (-1)，那么会变成 (-1)(1)(-1)
-   如果操作横跨 (1)(-1)(1)，那么会变成 (1)(-1)(1)(-1)(1)

也就是说总是表现为递增递减交错的情况，然后这个性质看起来就很好，考虑需要还原成的是一个 (1)，也就是需要消去这些(-1) 的段，发现只有在操作刚刚好在端点处的时候才会消去。所以，一个简单的构造方式是找到最后一个不合法的数字所在的段，然后交换到合法的位置。

但是发现这样搞过不了样例，因为分析错了，对于第三种横跨的情况，应该是变成 (1)(1)(-1)(-1)，然后就失去了这个良好的性质 GG。

思考了一下这道题的可做点，一个是 k 很小，另一个是操作是可逆的，所以可以考虑找到一种中间状态之类。但是发现没有什么优秀的中间状态了，GG。同时注意到操作可逆并不意味着操作无序，操作显然是有顺序的分别的。

时间来到 10:30，打完了 T1 所有会的部分分，猜想为什么部分分给的是 n<=16，明明 n^5 的做法还可做到更大之类。

稍微思考了一下，经由上面的分析，发现对于一个递减或递增的段，我是不会拆开的。

于是这样写，但是问题是过不了第一个样例，冷静思考了一下，发现我其实不知道一个连续段是由于巧合造成的，还是因为本来就是连续的。思考了一下，感觉有点绝望，显然不可以把连续段全都拆开，那样就退化成暴力；那么可能的解决方案是随机选择一些连续段拆开，但是这样感觉就很假。

尝试转化题意，题意等价于选定 k<=3 根对称轴和长度，让 n 个点到对应的位置，性质是每一个点是相对独立的。但是也不太可做/oh

正解是考虑一段连续段需要拆~~貌合神离~~，连续段长度肯定 <= k，因为可以想见，出现这样的情况必然是一个一个“搬运”过来的（如果两个数字一起搬，那么不形成连续段）。

所以就好做了，对于长度 <= k 的连续段，拆开即可。

---

T2，第一眼看起来很像原题，赛后发现不是，但是和 WZY PPT T13 这道构造题很相似。

把样例画出来手模了一下，猜测对于一个点，可以把儿子缩成一个点。

看了看部分分，对于初始所有点都没有颜色的情况，显然此时 Alice 胜，同时所有叶子都是可以选择的。

思考如果有颜色，得到一个结论：一个叶子可以选当且仅当选了这个叶子之后，这个叶子深度最低的非根祖先的颜色变成 Alice。

但是这个结论看起来就很难蚌，因为首先需要判定整个局面是不是 Alice win，然后对于每一个叶子判定选择之后能否造成改变。

尝试着尝试着开始写，但是写的过程中全是问题，感觉不确定的地方太多了，一个子树的状态貌似有很多种：先手胜利，后手胜利，Alice 必胜, Bob 必胜。

同时可以得到一个结论：如果选择了一个先手必胜的子树，那么此时必定交换先后手，我后手到了最后一步肯定就不和你玩了。但是这个结论残留的一个问题是该子树中没有取到的叶子们怎么办，但是显然问题不大，根本不用管。

时间来到 12:20，有点自闭，感觉按照这个分析写下去是不可做的。

看了一眼部分分，对于树高 <= 3 的情况，发现可以暴力手动分类讨论。边写边分析，发现根本不存在后手必胜的情况，想起来就很抽象。

如果一个点初始就是黑色，这个点可以被叫做 Alice 必胜；一个点初始是白色，那么 Bob 必胜；没有颜色，先手必胜。发现向上递推父节点的胜负情况是简单的。

其实这个就是正解了，考场很可惜没有写出来，被两个细节卡了：

-   \-2 是黑色，-1 是白色，考场看反了/oh
-   由于是枚举一个叶子染黑，那么实际上先手变成了 Bob，所以如果整体的局面时先手必胜那么也是不行的。

---

综上看起来，还是心里面有点急躁。一方面，感觉对 T12 的挖掘已经很到位了，没有找到可以挖掘的方向了；另一方面，可能是因为考试前一天晚上对 wyx 立下 flag：“明天给你表演切两道题以上”，但是事实可能只能切 T4。

> 浮名浮利，虚苦劳神。

### 2.15 自习

上午在写 20230213T3 加边(link)，写的中途中给 zqm 讲了 异或集合 的容斥方法，对容斥方法有了一定的更深的理解。

中途 czl 来问我 线性基求交，我发现我不会了，于是花了可能 1h 再度看懂，然后花了一些时间给 czl 讲。

终于在上午即将结束的时候写完了 link。

下午，思考 CF1616H Keep XOR Low，大致的点都分析到了，只是需要把得到的性质更形式化一点。

czl 找我问 FWT 有关知识，我发现我不会了，于是花了一定时间学习。给巨佬讲明白一个 FWT 有关证明之后，了解道巨佬今天学习的是一种挖掘 FWT 和正交线性基的关系 的高明思考，于是想着顺带着多学一点，发现实际上就是 CF1336E2 Chiori and Doll Picking (hard version) 这道题的关键。

晚上来把 CF1616H 写掉，然后继续看 CF1336E2，想起来这个是 gls 以前讲过的题目。最终还是剩下一点东西没有看懂。

和 zqm 一起发现了 树上游戏 的题解的谬误，并提出了正确的证明。

-   link：贡献可以拆分成三种：一条没有被覆盖过的边+其他任意边；一条仅被覆盖过一次的边+对应边；两条树边，使得覆盖这两条边的集合相同。一二种贡献可以用线段树随便维护，考虑第三种贡献。称被同样集合覆盖的为一个等价类，发现整个过程就是不断分裂等价类的过程，显然这个分裂过程最多进行 n 次。考虑每次分裂的时候需要给等价类中每一个点重标号，为了保证复杂度，使用启发式分裂。
-   CF1616H Keep XOR Low：首先假设是从 \[1,n\] 里面选择子集而不是从 a1,a2,...,an 中选择，对于大于 x 最高位的数字，所有位置都应该进行相同的选择。考虑 x 的二进制最高位 i，限制在于第 i 位取 0 和 取 1 的两个集合，进一步分类讨论，发现有限制关系的始终只有两个集合，那么就很可以做了。

感觉今天总体来说还行，只不过下午略感困倦，状态不是太好。

### 2.16 自习

上午终于搞懂了 CF1336E2，写了一部分代码，下午被卡常了 1h，原因是 2^{rank} 枚举线性基 A 能够张成的线性空间 F(A) 时，如若从线性基的高位开始 dfs，即先考虑 a\[60\] 选不选，由于 insert 进入线性基的数字都比较大，所以 i 比较大的时候，a\[i\] 大概率有值。那么这样会导致的后果就是递归栈长度比较长(???)，然后造成常熟影响。对于上述问题，解决方案是从小往大 dfs，觉得还是不科学的话，可以直接二进制枚举。

二进制枚举常数肯定是没有问题的。

上午还简单扫了一眼骗分导论，觉得没啥意思；解答了一个关于 纸牌 的问题。

之后帮 zqm 找 内鬼 RE 的原因，发现原来是题目数据范围和实际数据不同/ruo

然后去看 黄忠庆功宴，发现看得不是很懂，于是去看 马超战潼关，并通过了。

今天上午略水。

### 2.17 自习

总算是看懂了 黄忠庆功宴，并和 zqm 一起讨论修正了题解中对于 一定可以找到 (x, y), x\\le \\sqrt p, |y|\\le \\sqrt p，使得 kx - y \\equiv 0\\pmod p 的鸽巢原理证明。然后尝试自己写代码，调了很久。

口胡正确了 CF1704F Colouring Gam 的结论，巧妙的是在求解 SG 函数的时候，SG 函数可能是存在循环节的。

看了较久的 \[UOJ703\]赵云八卦阵，类似 新年的复读机，关键性质是线性基只会改变 logV 次，从后往前决策，对于不会使得线性基改变的点，能选就选肯定是最优秀的，因为它的取值范围是前缀最大的，于是可以考虑将这些不会让线性基改变的连续段一起处理。

官方题解的思考是正向 DP，然后充分利用线性基求 rank 的本质，从 dp 维护最小值，变成维护最小值在线性基中的 rank；这样的好处是当线性基发生改变的时候，可以 O(1) 地维护 rank 的变化，O(1) 地查询第一个比 x 大的且在线性空间里面的数，而优化了线性基操作附带了 logV

思考 CF1033G Chip Game，想到了可以 mod (a + b)，然后剩下的情况类似于 Alice 有一些可以用于拖延的点，有一些先手必胜，但是胜利后立即交换先后手的点。后手必胜的点显然可以忽略，因为进入这个点博弈之后先后手不变且对答案没有影响。分析到这里就停下了，感觉剩下的东西不是很好做了。

考虑先手一定是取最大的，后手次大，先手第三大……，然后我们发现一个显然的结论，假设先手赢的状态是 1 那么当 x+y 是定值时，(x,y) 随着 x 的增大一定是一个单调不升的序列，(y,x) 一定是一个单调不降的序列；那么，我们就可以通过二分得出这两个临界点，然后计算答案即可。

---

感觉自己应该控制 QQ 的使用。

### 2.18 自习

今天总算是把五虎上将全部杀完了/yx/mgx

张飞卷精兵：胜者是败者的父亲，贡献的计算方式是奇数层的和-偶数层，同时要保证父亲的权值比儿子大，填了父亲才可以填儿子（解锁）。那么一个显然的贪心想法是从大向小填，如果当前能填入偶数层节点则直接填入，否则选一个节点填入，使得被解锁的节点数最多，如有多个任选即可。画出来可以发现如果存在多个点儿子数量相同，对于儿子数量相同的点，子树都是同构的，所以可以任取。后续只剩下计算答案的问题。

关羽下象棋：分类讨论题，明确了答案 <= 4 之后比较好做。

CF1750F Majorty 有趣的正难则反。首先可以知道，将 0 视作 -1，可以把一个连续段缩成一个数；如若考虑一个序列合法的条件，发现是难蚌且难以直接 DP 的，但是不合法的条件是非常清楚的，即对于任意相邻的三个数 $x, y<0, z, |y| > x + z$。如此可以设出一个 dpij 表示长度为 i 的串，最后一段 1 长度为 j；钦定首尾必定为 1， 发现 dp{i, 1....i-1} 是可算的，用总方案数 ($2^{i-2}$) 减去即可得到 dp{i, i}。dp 的过程可以两次前缀和优化。

「雅礼集训 2018 Day7」A ：经典的势能分析，10min 一遍过。网上大部分题解的处理方式都是先把 a | b 转化成 $!(!a \cup b)$，感觉没有什么必要。

---

2.19 晚上

看懂题解之后自己写并调出了 K-d sequences

口胡了 ABC ABCDG，写了 E， F 题看错题面了/ll

### 2.20 模拟赛

时间分配：1h+10min+3h20min

成绩：100pts + 0pts + 5pts

感觉做 T3 的时候时间过得很快啊，明明感觉没有分析出多少东西，没有写多少代码，但是时间就是过去了，仿佛活在梦里。

---

T1 很诈骗啊，首先把 1.129... 对应次方输出出来看，发现其实都不是很大。注意到左边是一个 prod 的形式，那么如果出现 0 就 GG 了。排除掉 0 的情况，简单分析可以计算出左边的下界，下界在菊花图取到，发现是恒大于右边的。所以现在的问题转化为求解 $\sum_{a_1, a_2,\dots a_m}\prod_i siz_{a_i}$，套路删边变加边，那么每次的操作是删除一个 sz 或者加入一个 sz。可以设 dp 求解上面的式子，发现只需要维护 dp\_i{0....m}，容易 O(m) 每次处理一个操作。

T3 构造，当时考虑了以下几个点：操作近似可逆；考虑推广全是 0 的方案；考察只有一个 0 怎么办；如何判断无解；$k<\frac n2$ 的作用

然后大致得到了这样一个解法：首先想办法转化成只有一个 0 的情况，对于当前的局面，猜测当 n 足够大的时候，构造的方案是统一的，暴力打表把这个方案找出来即可；n 小的时候直接暴力算就好。

可惜的是，由于代码实现能力比较难蚌，在写“转化成只有一个 0”的过程中，花费了较多的时间调试，导致最后时刻突然发现猜测的结论是错误的，GG。

---

T1，std 使用了一个愚蠢的 nm^2logm 的线段树来维护上面所述的 DP。

T2 妙妙题，需要一点数论功底。首先，为了避免混循环小数，我们先把分母通过乘上2的幂次都变成奇数。对于整数部分，直接异或就好。

考虑小数部分，首先求出循环节，设 a 的循环节长度 n, b 的长度 m，显然有 O(nm) 的暴力做法。

思考我为什么必须要扫描 O(nm) 个位置，想到我如果能够只扫描 O(n) 个位置就好了，考虑把异或运算替换一下。发现对于 & 运算而言，仅在二者都为1的时候有值，看起来就比异或优秀，于是，首先通过 a \\oplus b = a + b - 2 \* (a \\cup b) 转化一下。

设 a, b 二进制循环节 p, q, 现在需要求解的是 $\sum_{i, j, p_i = q_j = 1} 2^{-pos(i,j)}$，其中 pos(i, j) = x，表示 x % n = i, x % m = j。

看到下面的式子可以联想到中国剩余定理，但是中国剩余定理要求 n, m 互质。实际上也好办，设 g = gcd(n, m)，可以将每一个位置表示成 kd + i 的形式，容易发现对于 除 d 余数不同的位置，其 pos 是无解的。那么可以枚举 i = 0...d - 1，将 p,q 分类然后计算。

下面所称的 p, q 都是经过分类的。全部当成 i = 0 进行计算，最后乘上 2{-i} 即可。

运用 exgcd，求出 n mod m 意义下的逆元 n^{-1}, m mod n 意义下的逆元 m^{-1}，令 i = i \* m \* m^{-1}, j = j \* n \* n^{-1}，此时即是求解 $\sum_{i, j} (2^d)^{(i + j) \bmod nm}$

这个是好处理的，排序后，双指针分开处理 $< nm$ 的部分和 $nm \le x < 2\times nm$ 的部分。

复杂度 nlogn，由于快速幂出现较多，有一定常数开销。

T3 对所有位置按照 %3 进行分组。首先对首尾进行操作，使得每组异或和相同，钦定之后不会再操作首尾，于是可以断环。后面随便做，构造对首尾进行操作比较细节。

---

晚上补了昨天 ABC 的 F。

### 2.21 模拟赛

今天基本上全在 rush T3

一来感觉 T4 就很好做，把所有题目扫完一遍之后，T1 感觉就很诈骗，但是需要一个比较妙的转化；T2 感觉很可做；发现 T3 是比较喜欢的题目。

思考 T3，简明的思路是，类似 2-SAT，把给定的限制边当作点，使用扩展域并查集维护边与边之间的关系。考虑形成了若干个连通块，在每一个连通块内，只要确认了某一条链接两个点 (u,v) 的方向，其他都确定了。那么考虑贪心，发现唯一需要特别小心的是两个连通块的交集是某一个点的情况，可以理解为点双的割点是需要特殊处理的。容易处理出某一条边仅考虑连通块内部的贡献。现在的问题变成 n 条边，钦定一些边对颜色不同，对于有公共端点的点，若两边颜色相异，那么贡献为 wa + wb，否则为 max(wa, wb)，求贡献值最大值的最小。思考一下，第一感觉是需要上树形 DP，冷静分析一下，由于构成的是一个树形结构，所以直接从上往下贪心地定向就好，这样可以保证所有共点的情况都是取的 max，已经是最优了。

给 T2 打了一个暴力。9：10 开 ru T3；10:45 总算写完 T3 第一版，感觉码力真的太弱，细节不会处理；11:20 小进展；

第一步并查集的实现是丑陋的，为了找到具体的需要合并的位置，使用了垃圾的树剖+标记永久化的线段树。而且为了得到每一条边具体的标号，又上了一个线段树，但是实际上我并不关注具体的标号，我只关注 在不在同一个连通块和颜色的取值，实现是非常愚蠢的。

下午继续调，发现上述转化的问题在于，虽然说的却是一个树形的结构，但是可能存在 同一个连通块的多条边存在公共端点，然后与另外一个连通块的边发生关系的情况。

所以贪心被破坏了，是需要 DP 的。

---

T4：注意到如果暴力维护的话，位数是有可能被卡到 O(N) 的。考察这个过程，发现维护的东西很多都是 0，冷静分析，发现只需要维护高位前 16 位即可。

T1：有结论，若 P(x) 为 k 次多项式，则 F(x) = P(x) − P(x + 1) 为 k − 1 次多项式。记对序列 a 的一次差分，表示同时令 ai = ai − ai+1，并扔掉序列末位。那么序列 a 和 b 相似当且仅当它们做 k + 1 次差分后完全相同。于是，我们只需先对 a 和 b 分别做 k + 1 次差分，然后用 kmp 跑匹配，找到第一个匹配长度大于等于 n − k − 1 的位置即可。

暴力做 k 次差分是 O(nk) 的，考虑直接计算 ai 对做了 k 次差分之后的 bj 的贡献系数，观察差分过程，可以知道是 (-1)^{j - i}C(k, j - i)，如此，NTT 即可

T2：若 (u, v) 在同一强连通分量内，则强连通分量数会改变当且仅当反转 (u, v) 后 u 不能到达 v。若 (u, v) 不在同一强连通分量内，则强连通分量数会改变当且仅当反转 (u, v) 后 u 能到达 v。

此时需要对于每一个 u,v ，求出删去这条边之后 u 是否可以到达 v。处理方式是考虑顺序遍历 u 的出边，对于遍历到的出边，做一次 bfs 的过程，把新的可以到达的点标记，如果在刚刚遍历到 (u,v) 的时候，v 已经被标记了，那么说明是可达的。再逆序做一遍上面的过程即可。使用 bitset 优化，复杂度 n^3/w

T3：有一种聪明的做到上述线段树+树剖过程的做法，是再开一个并查集，每次操作一条链，就把这条链缩起来，这样就可以不重复地连边，使得连边只会又 n - 1 次；很像最近做的一道字符串题目，大意是每次钦定一个区间是回文串，询问能否确认两个区间是否相同，做法利用了每次给定回文串实际上是给定一些对字符相同，把相同的字符所称并查集，merge 只会执行 n - 1次；这个在树上快速跳跃的技巧 gls 之前在某道题里面也讲过。

剩下一点 DP 的内容，运用一点智慧可以得到。

---

感觉今天下午晚上比较划水，亟待调整，急需反思。

### 2.22 自习

今天干了啥：

-   写昨天 T3赛道修建 的代码，感觉还是非常巧妙的
-   写 鸽子提瓦特 代码，对一个细节有了更深的理解：所谓 把下标按照 %3 分组，希求通过操作首尾使得每组的异或和相同，实际上这里的异或和维护的是 0 的数量的奇偶性，因为考虑当三组的异或和为 0 的时候，我实际上要求的是全都是 1；假如我真的维护是异或和，那么实际上最后呈现的情况不太对，可能会出现 0 没有消掉。
-   XXII Open Cup GP of Nanjing – I：巧妙的处理，将镜面反射看成是把整个地图沿着直线对称过去，而保留小球的速度不变。以此分析，发现可以以 x + y, x - y 为特征值处理问题。从左往右扫，维护 fs 表示目前状态为 s 能得到的最大分数。  
    (x, y) 的硬币的效果是让 fx+y, fx−y 都加一。因为反射点可以保留也可以删除，相当于可以任意选择方向，因  
    此 (x, y) 的反射点的效果就是让 fx+y, fx−y 都变为两者的较大值。
-   CF1764E Doremy’s Number Line：简单贪心题
-   AGC006D\]Median Pyramid Hard：发现题解区有一个 O(n) 的做法，思想是去二分化，重做了一遍
-   CF1682E Unordered Swaps：关键性质显然是题目保证 m 次操作是最小且合法的，思考如果我可以任意交换，那么我肯定是顺着置换环($i\to pi$)交换，对于一个长度为 L 的环我只会操作 L - 1 次。那么，容易发现 x, y 必然是环上的端点，且 x,y 之间必然不能相交，除非在端点处相交。考虑在端点处相交的 x,y，操作顺序必然是与原置换环的拓扑序相同。
-   CF1746F Kazaee：随机化题，给每种权值随机一个映射，判定这个区间每一个数出现次数都是 K 的倍数换成判定这个区间的映射和是否是 K 的倍数。神似 CSP2022ST3 星战，回去看了一眼。

### 2.23 自习

今干天了啥：

-   CF1705F Mark and the Online Exam：我的思考是：首先有一个 1002 次的做法。发现在询问了一次全 F 之后，我可以 1 次询问了解到某一个集合 T 的数量，那么可以考虑设计出 O(T 的数量) 和 O(F 的数量）的算法，拼起来就只需要 n/2 次操作，很可惜没有设计出来。然后考虑了询问 TFTFTF... 的形式是否会有帮助。思考方向是线段树，联想到到 “线段树底层暴力做”的 trick，考虑能否可以迅速地解决 n = 4 的情况，因为感觉上随机化蒙对的概率是有的。可能的问题是题目特意卡这个算法，问题不大，我可以手动在本地 random\_shuffle。一看题解，确实是这样的。还有一种[方法](https://www.luogu.com.cn/blog/Kok-kok/solution-cf1705f) 是用 2 个操作解决 n = 3，利用了TFTFTF 类询问
-   AGC010F Tree Game：简单博弈论，从下往上分析即可。
-   Invertation in Tournament：纯纯的结论题，哈人。
-   「JOISC 2017 Day 2」门票安排：神仙推性质题。题目容易转化成，m 个区间 \[l,r\] 或者 \[1,l)+(r,n\]，求每条线段覆盖次数的最大值最小是多少。首先把所有区间整理成 \[l,r\] 的形式，计算当前的覆盖次数 ai，考虑如何翻转，设经过一个反转方案之后的覆盖次数是 bi。首先可以发现，翻转的区间两两必然有交集，画画图是容易证明的。那么考虑一定存在一个区间 \[l,r\] 是所有反转区间的交集，考虑在最优解中，这个区间内享受了最多的“优惠”，故而可以感性理解：设 $mx = \max ai$，那么所有 a\_t = mx 一定都在这个区间内，严谨的证明可以看 [pb](https://www.cnblogs.com/p-b-p-b/p/13097360.html)。如是，枚举答案 w，可以知道翻转的区间个数应该是 cnt = a\_t - w (+1)，问题转化为：要求反转了 cnt 个区间之后（这些区间均满足 $l_i <= t, r_i <= t$），设反转区间覆盖 ai 位置 xi 次，满足 $ai-xi+cnt-xi<=w$，(同时自然满足 xi 递增）；在此基础上，要求反转的这 cnt 个区间对 (r, n\] 的影响不至于使得 \[t + 1, n\] >w。 这个可以用一个贪心来做，枚举 1...t，在优先队列里面加入可以翻转的区间，如若当前需要翻转，从优先队列里面取出 r 最大的进行翻转即可。这样可以使得后面尽量合法。
-   Growing Flowers：之前就在做，没写出来的题。放弃了修补自己的解法，因为觉得太复杂了。学习了一下聪慧的正难则反的容斥和优雅的代码实现。
-   CF1458D Flip and Reverse：神仙建模转化题。考虑用 -1 代替 0，设 si 表示前缀和，si 向 s{i+1} 连边。在这个意义下k考虑操作 \[l,r\]，首先要求 s\[l - 1\] = s\[r\]，那么此时操作的是一个环，操作等价于将环上的边反向。观察到操作前后，边集 E 是保持不变的，因为一旦我翻转了有向边 x->y，由于操作的是一个环，我必然翻转 y->x，因此我们可以把这些边都当作有向边。此时，有结论，新的无向图的任意一个欧拉回路，和原字符串经过操作可以得到的字符串可以建立双射。具体的证明可以考虑欧拉回路的路径和原字符串的第一个分界点，利用翻转操作，容易使得两条路径重合，即消去这个分歧点，归纳即可。

感觉这几天脑子有点容易困倦，看了一点东西就想睡觉，但是这两天平均 23：00 睡觉，不知道，可能欠了太多瞌睡了。

### 2.24 自习

-   Gym102586D Xor Sum：很巧妙的一道题。首先一个误区是：a + b = a\\oplus b + 2 \\times a and b 不代表这个结论可以扩展到 n 个数的情况，所以不能把和为 S 的限制转化为 and 和为 S^{\\prime}。常规的数位 DP 方式是，二分答案，然后设 f\[i\]\[j\]\[k\] = 1/0 表示处理了 i...60 位，j 个数字顶了上界，存在 k 位进位 是否可行，这样的复杂度是不可接受的。思考如若我已经有了一组满足条件的方案，如何使得最大值尽可能地小。设 ci 表示该方案中二进制第 i 位 1 的数量，发现我一定可以通过 ci - 4, c\_{i + 1} + 2 的方式得到一组 $\forall i, c_i \le 3$ 的解，且在这个解的基础上进行变化可以得到所有的解，且 `c_i = (x >> i & 1) + ((s - x)/2 >> i & 1) << 1` 是一组合法的解。回到二分答案的判定问题，当前给定一个最大值，影响相当于是说需要把原来在高位的某些 ci 往下面放，即 ci - 2, c\_{i + 1}+ 4，最后如果发现在 <=mid 的限制下往下放放不了，那么就说明 mid 太小了。设 f\_{i, j} 表示决策了 i...60 位，当前有 j 个数字 < mid （没有限制，可以任意取）的最小的需要下放的位数。 容易发现，如若存在 fij 使得 j>=3 且 fij = 0, 那么已经 win 了。转移考虑 mid 当前位置，如若为 0，那么只能往下传；否则枚举 f\_{i - 1, k}，考虑计算 还需要下传的位数 = f\_{i, j} 传下来的 + 本身构造的解 - (n - k) 个位置顶住了 mid - j 个位置可以填 1。显然这里肯定是贪心地尽量填 1。考虑 DP 第二维的大小，发现如若 k>=4 且 k > j + 1 那么显然是不优的，不如把这个自由位顶住上界来换取少下顺一个 1，因为下顺下去就变成 2 个了。所以 DP 的复杂度是 log^3V
-   CF1393E2 Twilight and Ancient Scroll (harder version)：比较简单的 DP 题。首先可以简单手玩考虑删除一个字符对字典序的影响，首先可以按照套路认为删掉一个 s\_x，删去的是连续段最后一个，那么此时只需要讨论 s\_x < s\_{x + 1} 和 s\_x > s\_{x + 1} 的情况，简单手玩容易得到 O(n) 对删掉各个位置之后的字符串排序的方法。设 fij 表示以 删除第 i 个字符串 j 个字符 作为当前严格上升子序列的最后一个字符串的方案数，容易发现转移时一个前缀，双指针随便做。发现需要做 O(\\sum|s|) 次字符串比较，可以 hash 求 lcp 做。代码细节比较多。
-   CF850 Rainbow Balls：势能法激光剑打原始人/oh/oh/oh，发现还是看不懂鞅与时停定理，但是 gls 的势能法讲得很好/gz/gz/gz。也去看了看常规做法的题解，感觉也是非常巧妙的，对期望有了更深入一点的理解。
-   CF809D Hitchhiking in the Baltic States：DS 优化 DP 套路题，口胡 FHQ\_Treap 但是写错了 3 个点，一个是 split 之后忘记了 merge 回去；一个是 del 的时候需要把找到的删除的点的儿子 merge 上去；一个是写 rt 写习惯了，int x 之后没有改过来。。。

### 2.25 模拟赛

-   8:45 发现看错了 T1 题目
-   9:15 写完 T1 正解
-   9:30 完成 T1 对拍
-   9:45 发现 T2 写错了，但是真的是原题
-   10:00 完成 T2
-   10:20 T3 初步想法
-   11:00 T3 DP 不会写/oh/oh/oh 属于是脑子蚌埠了
-   12:00 被 T3 打自闭了
-   12:30 T3 应该是前缀 DP!!!

可惜了，T3 3h 没有做出来。

---

T1 最开始看成了是翻转/复制然后接到序列的后面+脑子不太好，然后把式子推错了，有点尬，但是其实感觉影响不大的应该？

T2 没有看见可以随时重开，以为只能强制重开，那么显然可以主元法解题，主元法写完发现不对，原来还要取 min，那么就是经典 AGC军舰 的 trick，二分答案。

T3 数据范围看起来很区间 DP，于是我们考虑区间 DP。发现需要处理 g{i, o, j} 表示中间长度为 o 是已经可以确认了，左边长度 i 等待确认，右边长度 j 等待确认；还需要类似预处理一个 h{i, o, j} 表示用两边帮助中间。

这两个 DP 看起来是好做的，但是仔细想的话发现 DP 的初值是难蚌的，递推是困难的。观察 g 的转移，实际上可以得到 $g_{i, o, j} = fac[o + i + j] ifac[o] \binom{i + j}i$，但是 h 是难以直接计算的，直接计算有 O(N^4) 的方法，想要递推的话，发现还存在着算重的问题。

终于可以计算 f 了，发现 f 还是会算重，思考了很久没有找到解决方案，因为不管如何，由于存在一些边可以任意选，这些边非常难蚌！！！！

区间 DP 是坏掉了，那么考虑前缀 DP/容斥方向。想起来感觉这道题很像 \[CF1750F\]Majority，可能可以采用 f\_{i, 0} 不好算，算出 f\_{i, 1...n} 然后用总方案减去的这个思路。

大致转化成了这个问题：维护一个集合 {len}，每次使得 len.back() + 1, 然后要么 len.push\_back(0)；要么枚举 i >= 1，把 len 的某位 i 个元素 pop\_back() 掉然后 push\_back 这些元素的和，系数为 $\prod (2^{len_i} - 1)$。求问使得最后长成 {n} 的方案数。

实际上，按照这个写出来是错误的，因为上述做法等同于认为：要想使得答案在 x 的时候可以获胜，必然存在一个询问 \[l,r\]，使得 \[l,r\] 中除了 x 之外的都已经 win 了，但是实际上是错误的，比如 n = 3 时，我可以询问 (1,2),(2,3),(1,3)。包括上面做 区间 DP 的时候也犯了这个错误。

也就是说，实际上把 T3 的第一步转化都做错了，怎么还可能写出正解呢？大概还是心急了，看到 T12 形势一片大好，T3 一来就慌慌张张地做转化，这样是愚蠢的。

---

T3 正解：考虑合法等价于每一个点的被询问集合不同。这个转化很像前日考试 加边(link）一题。

观察一下有什么性质，容易发现不存在两个等价类相交，等价类只存在 无关/包含 的关系，那么一个等价类可以视作一个区间。

设 di 表示长度为 i 的答案，也即构成 i 个不同等价类的答案，因为我实际上可以把一个等价类看成是一个数。

考虑如何转移 d\_i，显然是容斥的形式，因为 dj 对 d\_i 的贡献显然都是不合法的贡献。考虑贡献系数，发现当前的情况可以理解为 i 个数字被缩成了 j 个互不包含的等价类，求方案数。

设 f\_{i, j} 表示上述问题的答案，枚举最后一段，有 $f_{i, j} = \sum_{k < i} f_{k, j - 1} 2^{(i - k - 1)(i - k - 2)/2}$。后面的系数的意思是 i - k - 2 个数（去掉首尾）任意进行询问的方案数，因为考虑长度为 i - k 的大等价类内部，等价类是可以存在包含关系的。

那么有 $d_i = 2^{(i + 1)i/2} - \sum_j d_j f_{i, j}$

整体来看这个 DP，发现也就是在枚举选择极大的等价类，然后在保证这个极大的等价类存在（i - k - 2 个数字去掉首尾）的条件下，让其内部随意生成被包含的等价类。这样是不重不漏的。

ohhhhhh

---

2.26 晚上

前半段稍微跟着 zqm 看了看 AGCDevelop 虽然没有看懂，然后开始尝试理解模拟赛 T4

ABC 开始了，去口胡，发现 ABCDE 都是简单题，F 看到 m \\le 10 瞬间矩阵上脑，说这道题用矩阵做，实际上也可以做，但是没有必要，但是矩阵还可以做到这道题的带修版本。

被 G 卡住了，可能想了一共 1h 左右的 G，思考了很久，感觉值域 < 31 的唯一作用在于可以把每一位拆开来算，那么现在可以把 a,b 都看成是 0/1 序列，求 f\[i\] 表示把 a 循环位移 i 位之后对应位的 or 和。到了这一步，感觉和 20230220T2 鸽子做加法 很像，考虑把 or 转成 and 做，这个是容易的。首先可以想到的是暴力 bitset，但是 n^2/w 也是不行的，之后继续考虑鸽子做加法那一套，发现由于要知道每一个 f\[i\] 而不是 f\[i\] 的和，所以是难蚌的。考虑转成 xor 做，考虑如何利用 a xor b xor a = b 的性质来进行这个循环位移的操作，发现也是难蚌的。考虑一种根号分治，即考虑值域很小，那么很有可能会出现循环节，显然有 O（循环节长度）的方法，现在只需要给出一个 O（n/循环节长度）的做法即可，发现给不出来，GG；

发现很多人过了 Ex，一看，发现 Ex 的题意等价于：给出一棵树，建出它的点分树。真虾头。

回来看 G，还是不会，题解是卷积做法，草！

其实是一个思维的盲区，首先是下意识认为 ABC 不会出现卷积这种东西，但是毕竟 JOI 和 CNOI 侧重点不同。其次，草稿纸上写出的式子是 $f[k] = \sum_{i =0}^4 2^i \sum_j a_{(j + k) \bmod n} \& b_j$，如果转化成 $a_{(j + k) \bmod n} \& b_{n - j + 1}$ 可能会更有卷积的感觉。

其次，and 和 times 的转化也是一个比较巧妙的没有想到的点。

### 2.27 模拟赛

-   7：50 昏昏沉沉没有脑子
-   8：10 决定 try T2
-   8：30 T2 是 sb 题？？？?
-   1 0：40 终于写完 T1 N < 1E6
-   11：15 给 T1 卡完空间，但是少算一个 vector 的情况下还是多了 5MB /ll
-   11：35 还是不会 T3 SP/oh/oh/oh

T1 原题，T2 简单期望题，分都拿到了，挺好。

---

T3：第一眼感觉比较 DS，但是不太会，首先容易有 n^2logn 的双指针配合线段树的暴力，这个暴力显然是没有什么优化空间的。考虑特殊性质分，所有 bi 都相同，此时考虑能否二分答案，判断 mid 是否可以成为最小的出现次数，那么现在的问题就是判定是否存在一个区间使得区间中所有数出现次数 > x，枚举 l，有 r = max \[prei < l\]i 后第 x 个 ai 的位置；这个东西比较难蚌，但是硬上线段树+双指针也是可以 nlogn 判断出来的，整体复杂度是 nlog^2n，n 是 1e6, GG。

其实上面的想法和正解是比较接近的。

考虑如何判定区间 \[l,r\] 能否成为答案，由于 bi 是递减的，那么最低的要求是所有数字的出现次数 >= b\[r - l + 1\]。

注意到如果区间中某一个位置 p 所代表的数字 ap 的出现次数 < b\[r - l + 1\]，那么所有是 \[l,r\] 的子区间且跨过 p 的区间显然都不合法。这启示我们可以把所有这样的 p 删掉，然后递归地往下做，直到某一个子区间不存在这样的 p，那么可以用这个子区间更新答案。

此时得到了一个 O(\\sqrt(n) n) 的解法，复杂度计算考虑出现次数不同的数只会有 \\sqrt n。

考虑优化这个算法，观察复杂度的一个瓶颈是找到所有不合法的 p，考虑能不能每次随机找一个然后分下去；这样，利用启发式分裂的想法，如果能够保证以 min（大段，小段）的复杂度处理好，那么复杂度就是对的。

考虑在 solve 的过程中维护 cnt 数组，使得每次进 solve(l,r) 的时候 cnt 里面恰好是 \[l,r\] 的信息，每次离开的时候将 cnt 清空。类似 加边(link)，直接两个指针分别在 l,r 同时往中间扫，可以在 min 的复杂度找到第一个 p，然后往下分治。发现这样搞 cnt 的处理也可以做到 min。

T4 正解巨大丑陋线段树区间合并，没有写的欲望。

---

晚上看了看链分治和 DSU on Tree 相关的东西，并思考理解了 [attack](https://www.cnblogs.com/zwfymqz/p/9683124.html) 中的“有趣的题目”

然后重看 青鱼和游戏，对一些细节更清楚了，发现还是看不懂，但是距离看懂 q(logn + logv) 的算法只剩下一个 calc 函数了/hanx

### 2.28 模拟赛

今天有点炸裂，场上状态不是很好。

T1 想当然了，没有证明贪心；T2 写蠢了；T3 满心希望正解是一个单 log 的 nb 做法，想着随便写一个 log^2 的玩玩，，没想到正解居然也是 log^2，只是常数比较优秀罢了。

---

T1，邻项交换法的应用。首先可以用邻项交换法证明知道对于同一列，应该是先尝试 p 比较小的，感性的理解是，先做不容易做的，后面的做起来轻松。现在的问题是考虑列和列之间的顺序。

一个看起来很直觉的贪心是设 $prob_j = \prod p_i$，即全部通过的概率，先尝试 prob 比较大的。

但是这样是错误的，是无证明的，一个简单的例子是，当两者 prob 相等的时候，先后仍然存在影响。求出 $e_j = 1 + p_1 + p_1p_2 + p_1p_2p_3+\dots$ 表示单独考虑第 j 的期望尝试次数：

-   先 i 后 j，期望次数为 ans1 = ei + (1 − probi)ej；
-   先 j 后 i，期望次数为 ans2 = ej + (1 − probj )ei。

令 ans1 < ans2，导出 ei/probi < ej/probj 是全序关系，那么按这个升序排序即可。

T3 配对堆优化 set

---

晚上回看了一下 20221022 的模拟赛的题，有了一点收获。

终于写掉了 **青鱼和区间**，非常巧妙的一道博弈。设 A 删 B 挪。

A 的一个简单策略是每次取最大的 ai 删掉；B 的最优策略是把 ai 分成 ai/2 上下取整，这个最优性是容易证明的。这样有下界 \\sum log a\_i。

现在假装在答案里面加了这么多不，下面计算可以省下来的步数。

A 显然有更厉害的策略，考虑假如 A 删掉了某一个堆，如若当前所有对 (a, b) 都满足 a=b，此时就逼迫 B 把某一个 (a, a) 调整成 (a - 1, a + 1)，可以发现这样是有希望省下步数的。比如把 (1, 1) 调整成为 (0,2)，就省下来一轮。

所以 A 必然不会容忍场上存在一组两边石子个数不同，如果存在不同，那么一定是一直操作这一组直到相同。

假设当前场上所有组都两边相同，考虑 B 被逼迫一步意味着什么。假如 B 操作 a，A 会选择 a + 1 删掉，模拟下去可以发现，最终会使得 a = a - lowbit(a)。

现在看起来是这样一个问题：A 每次可以删掉一个 a， B 每次 a-> a-lowbit(a)，如若 B 把某一个 a 清空，那么计数器加1，A 想使得计数器尽可能大，B 想使得计数器尽可能小。

显然有策略，A/B 都会对 ppc 最大的数字进行操作。A 的想法是逼迫 B 选择 ppc 小的，B 则要尽量避免计数器 + 1。

但是 A 还可以做到更好。考虑一个二进制数 （11100010101010）\_2 ，这个数字的 ppc 是很大的，看起来对 B 很优，但是 A 实际上可以通过“预处理”，先把这个数字处理成为 (111)\_2，在进行上面的博弈。（不能再操作了，再操作为了保证组内个数一致，必须删空）

所以实际上不是考虑 ppc，而是关注每一个数字的 leading\_ones 的个数。`__builtin_clzll(~(x<<__builtin_clzll(x)))-1`

有暴力模拟算法，设 c\[i\] 表示 leading\_ones 个数为 i 的数字个数， p\[i\] = 0/1 表示开始做 c\[i\] 的时候 A 是 先手/后手。

```c++
const int B=40;
inline int query(int l,int r)
{
	int c[B+1]={0},p[B+1]=0,g=0;
	for(int i=l;i<=r;i++) c[__builtin_clzll(~(a[i]<<__builtin_clzll(a[i])))-1]++,g+=(65-__builtin_clzll(a[i]));
	for(int i=B;i>0;i--) c[i-1]+=(c[i]+p[i])/2,p[i-1]=p[i]^(c[i]&1);
	return 2*(g-(c[0]-!p[0]))-1;
}

```

考虑优化这个过程，提出 c\[i\] 中的两个，A 每次删掉一个，B 让 i->i-1，也就是每轮操作实际上是把两个 i 合并成一个 i-1。可以想到令 i = 2^{-i}，不考虑 p\_i （先后手）的影响的话，对于询问 \[l, r\], 答案就是 $\sum 2^{-val_i}$ 的整数部分。

也就是说，这里如果把循环各轮的 c,p 分别倒过来组成一个二进制数，我们就是计算了c 和 p 的和，不过 c 的每一位可以 > 1，并且进到 B 位就停止。接下来使用这个定义的 c, p(也就是说它们都是倒过来的)。

继续考虑 p 是什么，可以发现它就是 c+p 上"经过"每一位的值的奇偶性的前缀和，也就是说如果向第 i 位发生了一次进位，对 $p_{j\ge i}$ 的贡献就是 xor 上一个 1。注意到如果 c 的某位值 > 2 则必然向下一位进位，考虑一下发现我们在 c 上做完这些进位，做法就是直接加起来，最后再跑一遍上面的模拟即可。用BiT支持单点修改区间求和，复杂度 $\mathcal{O}(q(logn + logv))$。

Bonus：可以把 logv 砍成 O(1)

---

写了 CF1290E Cartesian Tree，吉司机线段树模板毕业题。

### 3.1

-   \[AGC043D\] Merge Triplets：小清新推性质，很好地利用 3。整个过程可以转化为一个求拓扑序的模型，但是转化成拓扑序是没有进一步的空间的。发现限制特殊在 从栈低到栈顶 递减的情况，如果是递增的，那么显然可以忽略必须先拿走栈底的限制。考虑如果选了栈底 a，新栈底 $b < a$，那么下一步一定是选择 b，所以假如我把这种递减的 a, b 缩成一个数字，那么可以当成是 没有先拿走栈底的限制 的情况，即一个简单的归并排序的过程。那么可以得到一个条件，即最后生成的排列中，所有递减的连续段长度 <=3；发现这样还是不够，比如 214365 其实是不合法的，原来还需要保证长度为 2 的段数 $\le$ 长度为 1 的。执行一个 DP 即可，DP 过程比较巧妙， fij 表示使用值域 1...i, 2段和1段个数差值j。考虑如果新加入一个 2 段，做的转移是 fij(i+1)\\to f{i + 2, j + 1}，(i + 1) 的意思是先把 i + 2 放到某一个栈的栈底，然后随便选一个数字放在 i + 2 的上面，容易发现一定存在唯一一种调整方式使得状态仍然合法。一个担忧是会不会 i + 2 实际放在栈的中间位置，这是不用担心的，因为如果放栈中，那么栈底必须小于 i + 2，不然成为一个长度为 3 的段，然而 < i + 2 的数已经安排好了。
-   CF1327F AND Segments：套路拆开二进制，套路把限制区间转化为不存在包含，容易记一个 dp，容易 DS 优化 dp。
-   \[CF1749D\]Counting Arrays：简单转化条件
-   \[TopCoder14286\]TriangleTriples：比较有趣的容斥，把所有东西都形式化出来。

下午在打摆，晚上在回顾自己写的 OI Tricks 等等，感觉缺少学习的动力，可能是有点疲惫了。

### 3.2 信心赛

-   8：00 看完题目
-   8：30 感觉今天没有手啊啊啊啊
-   8：45 T1 过拍
-   10：00 总算调出 T2
-   10：10 T2 map->segment 用力卡常
-   10：25 不管 T2 了，被卡常就开喷！
-   11：15 发现 T3 maker 写错了/lh
-   11：30 发现 T3 是 欧拉序 写错了/qd
-   11：40 发现 T3 是 贡献不应该 break /jk，过对拍，爽起来了
-   11：50 写完 T4 暴力，双手离开键盘

最后都没有挂分，挺好。

今天的题，只能说明 wyb 一定程度上有稳定切 T1 的能力，但是侧面反映出不足，三道题，尤其是 T23，在较快地想出了正解的情况下，均花费了较久的时间对拍查错，上考场做 T234 不会太乐观。

但是没挂分，还是给人以信心的，毕竟是第一把没有垫底的信心赛。

订正完开始看字符串，重看 SAM，看了一点点数论。

感觉状态和昨天晚上比较像，划水是不乐意的，但是静下心来学东西还是不大行。

我感知着心中纷乱的头绪，不断想要使自己明白后天的考试不过是人生的一个小部分，不是什么结局，更应该是同任何一个瞬间一样无时无刻绽放生命光彩的片刻。我恍然中了然对这场比赛的重视程度，期待责任完成的瞬间。

> 切勿为部分生活落泪，君不见一切人生都催人泪下。