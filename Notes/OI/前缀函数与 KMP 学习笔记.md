## 引入

我们先给出这样一个简单的字符串匹配问题：

给定两个字符串 $s$ 与 $t$，记 $n = |s|, m = |t|$，其中 $n \ge m$。求 $t$ 在 $s$ 中出现的首位置的集合，即 $\{x | s[x..x + m - 1] = t\}$。（字符串下标从 $1$ 开始）

如果我们使用朴素的暴力枚举位置 $x$，并暴力判断字符串是否相等，我们可以得到一个 $O\left(n^2\right)$ 的算法。我们可以对其进行进一步优化。一种方法是在判断字符串相等上下功夫，即使用字符串哈希实现 $O\left(1\right)$ 判断，从而使原算法优化为 $O\left(n\right)$。而另一种方法是在枚举 $x$ 上下功夫，从而优化匹配的过程。

例如，我们令 $s = \mathrm{ababazababa}, t = \mathrm{abababa}$。如果我们使用暴力判断，当 $x = 1$ 时，我们发现 $t$ 在第 $6$ 个位置失配；然后我们移动到下一个位置 $x = 2$，失配；当 $x = 3$ 时，我们发现：由于 $t[1..5] = t[3..7]$，$x = 3$ 注定失配！因为我们已经在 $x = 1$ 的时候，$t[6..7]$ 与 $s[6..7]$ 已经失配，所以 $t$ 往后移动，仍然不能匹配。

这时，我们考虑如下的前缀函数，来优化我们的暴力。

## 前缀函数

对于长度为 $n$ 的字符串 $s$，其前缀函数被定义为一个长度为 $n$ 的数组 $\pi$。其中 $\pi_i$ 定义为