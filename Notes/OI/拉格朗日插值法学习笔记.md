## 定义

拉格朗日插值法（Lagrange Interpolation）是由法国数学家拉格朗日提出的用不超过 $n$ 次的多项式拟合平面上 $n + 1$ 个点的多项式构造方法，在~~乱搞题~~数学题中有很广泛的应用。

## 算法原理

如果我们从未学习过拉格朗日插值法，我们可能会想到使用待定系数法，设 $f(k) = a_n k^n + a_{n - 1} k^{n - 1} + \dots + a_1k + a_0$，将 $n + 1$ 个点带入并使用高斯消元法求解，不过这不仅会造成精度问题，还带来了 $O\left(n^3\right)$ 的巨大复杂度瓶颈。不过拉格朗日插值法就能完美解决此问题。

设已知的 $n + 1$ 个点分别为 $P_1(x_1, y_1), P_2(x_2, y_2), \dots, P_{n + 1}(x_{n + 1}, y_{n + 1})$，所求多项式为 $f(k)$。考虑这些点在 $x$ 轴上的投影 $Q_1(x_1, 0), Q_2(x_2, 0), \dots, Q_{n + 1}(x_{n + 1}, 0)$。如果我们构造 $n + 1$ 个辅助多项式 $g_1, g_2, \dots, g_{n + 1}$ 使得 $g_i$ 过 $P_i$ 和剩下 $n$ 个 $Q_j (j \neq i)$，那么所求的 $f(k) = \sum_{i = 1}^{n + 1}g_i(k)$，正确性显然。

考虑如何构造 $g_i$。我们令 

$$
g_i(k) = y_i \prod_{j \neq i} \frac{k - x_j}{x_i - x_j}
$$

这样，当 $k$ 取其他 $x_j$ 时，后面总有一项的分子为 $0$，故 $g_i(x_j) = 0 (j \neq i)$，而 $k = x_i$ 时，后面每一项的分母与分子都是一样的，所以 $g_i(x_i) = y_i$。因为平面上 $n + 1$ 个点唯一确定一个 $n$ 次多项式，所以此构造正确性成立。朴素求解时间复杂度 $O\left(n^2\right)$，使用一些多项式黑科技可以做到 $O\left(n \log^2 n\right)$，~~可惜我不会~~。

## 例题

### Luogu P4781 【模板】拉格朗日插值

摘要：拉格朗日插值，数学

[传送门：https://www.luogu.com.cn/problem/P4781](https://www.luogu.com.cn/problem/P4781)

#### 题意

给定平面上 $n$ 个点 $(x_1, y_1), (x_2, y_2), \dots, (x_n, y_n)$，确定一个 $n - 1$ 次多项式 $f(x)$ 过这 $n$ 个点，并求出 $f(k) \bmod 998244353$ 的值。

#### 分析思路

模板题，思路题见上。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
template <int mod>
inline int down(int x) { return x >= mod ? x - mod : x; }
template <int mod>
struct ModInt {
    int x;
    ModInt() = default;
    ModInt(int x) : x((x % mod + mod) % mod) {}
    friend istream &operator>>(istream &in, ModInt &a) { return in >> a.x; }
    friend ostream &operator<<(ostream &out, ModInt a) { return out << a.x; }
    friend ModInt operator+(ModInt a, ModInt b) { return down<mod>(a.x + b.x); }
    friend ModInt operator-(ModInt a, ModInt b) { return down<mod>(a.x - b.x + mod); }
    friend ModInt operator*(ModInt a, ModInt b) { return (long long)a.x * b.x % mod; }
    friend ModInt operator/(ModInt a, ModInt b) { return a * ~b; }
    friend ModInt operator^(ModInt a, int b) {
        ModInt ans = 1;
        for (; b; b >>= 1, a *= a)
            if (b & 1) ans *= a;
        return ans;
    }
    friend ModInt operator~(ModInt a) { return a ^ (mod - 2); }
    friend ModInt operator-(ModInt a) { return down<mod>(mod - a.x); }
    friend ModInt &operator+=(ModInt &a, ModInt b) { return a = a + b; }
    friend ModInt &operator-=(ModInt &a, ModInt b) { return a = a - b; }
    friend ModInt &operator*=(ModInt &a, ModInt b) { return a = a * b; }
    friend ModInt &operator/=(ModInt &a, ModInt b) { return a = a / b; }
    friend ModInt &operator^=(ModInt &a, int b) { return a = a ^ b; }
    friend ModInt &operator++(ModInt &a) { return a += 1; }
    friend ModInt operator++(ModInt &a, int) {
        ModInt x = a;
        a += 1;
        return x;
    }
    friend ModInt &operator--(ModInt &a) { return a -= 1; }
    friend ModInt operator--(ModInt &a, int) {
        ModInt x = a;
        a -= 1;
        return x;
    }
    friend bool operator==(ModInt a, ModInt b) { return a.x == b.x; }
    friend bool operator!=(ModInt a, ModInt b) { return !(a == b); }
};
using mint = ModInt<998244353>;
inline void optimizeIO(void) {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
}
inline mint lagrange(vector<mint> &x, vector<mint> &y, mint k) {
    mint ans = 0;
    const int n = x.size();
    for (int i = 0; i < n; i++) {
        mint cur = y[i];
        for (int j = 0; j < n; j++) {
            if (j == i) continue;
            cur *= (k - x[j]) / (x[i] - x[j]);
        }
        ans += cur;
    }
    return ans;
}
int main(int argc, const char *argv[]) {
    int n;
    mint k;
    optimizeIO(), cin >> n >> k;
    vector<mint> x(n), y(n);
    for (int i = 0; i < n; i++) {
        cin >> x[i] >> y[i];
    }
    cout << lagrange(x, y, k) << endl;
    return 0;
}
```

### LibreOJ #165. 拉格朗日插值（重心拉格朗日插值模板）

摘要：拉格朗日插值，数学

[传送门：https://loj.ac/p/165](https://loj.ac/p/165)

#### 题意

维护一个点集 $S$，支持 $n$ 次操作：

- `1 x y`，将 $(x, y)$ 加入点集，保证点集中点的横坐标两两不同。
- `2 k`，求 $f(k) \bmod 998244353$ 的值，其中 $f(k)$ 为一个不超过 $|S| - 1$ 次的多项式，且过 $S$ 中的所有点。

#### 分析思路

如果每次暴力使用拉格朗日插值法，时间复杂度为 $O\left(n^3\right)$，难以接受。我们考虑对普通拉格朗日插值的构造方法进行变形：

$$
\begin{aligned}
f(k) &= \sum_{i = 1} ^ {n + 1} y_i \prod_{j \ne i} \frac{k - x_j}{x_i - x_j} \\
&= \sum_{i = 1} ^ {n + 1} y_i \prod_{j \ne i}(k - x_j) \prod_{j \ne i} \frac{1}{x_i - x_j} 
&= 
\end{aligned}
$$

#### 代码



## 参考文献


